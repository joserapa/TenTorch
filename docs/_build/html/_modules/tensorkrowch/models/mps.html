
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tensorkrowch.models.mps &#8212; TensorKrowch 1.0.1 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <link rel="shortcut icon" href="../../../_static/tensorkrowch_favicon_light.svg"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/tensorkrowch_logo_light.svg" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../tutorials.html">
   Tutorials
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/0_first_steps.html">
     First Steps with TensorKrowch
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/1_creating_tensor_network.html">
     Creating a Tensor Network in TensorKrowch
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/2_contracting_tensor_network.html">
     Contracting and Differentiating the Tensor Network
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/3_memory_management.html">
     How to save Memory and Time with TensorKrowch (ADVANCED)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/4_types_of_nodes.html">
     The different Types of Nodes (ADVANCED)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/5_subclass_tensor_network.html">
     How to subclass TensorNetwork to build Custom Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../tutorials/6_mix_with_pytorch.html">
     Creating a Hybrid Neural-Tensor Network Model
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../api.html">
   API Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../components.html">
     Components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../operations.html">
     Operations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../models.html">
     Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../initializers.html">
     Initializers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../embeddings.html">
     Embeddings
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../decompositions.html">
     Decompositions
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/joserapa98/tensorkrowch"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for tensorkrowch.models.mps</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This script contains:</span>
<span class="sd">    * MPS:</span>
<span class="sd">        + UMPS</span>
<span class="sd">        + MPSLayer</span>
<span class="sd">        + UMPSLayer</span>
<span class="sd">    * AbstractConvClass:</span>
<span class="sd">        + ConvMPS</span>
<span class="sd">        + ConvUMPS</span>
<span class="sd">        + ConvMPSLayer</span>
<span class="sd">        + ConvUMPSLayer</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">ABC</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">Text</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>

<span class="kn">import</span> <span class="nn">tensorkrowch.operations</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">tensorkrowch.components</span> <span class="kn">import</span> <span class="n">AbstractNode</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ParamNode</span>
<span class="kn">from</span> <span class="nn">tensorkrowch.components</span> <span class="kn">import</span> <span class="n">TensorNetwork</span>
<span class="kn">from</span> <span class="nn">tensorkrowch.models</span> <span class="kn">import</span> <span class="n">MPO</span>

<span class="kn">from</span> <span class="nn">tensorkrowch.utils</span> <span class="kn">import</span> <span class="n">split_sequence_into_regions</span><span class="p">,</span> <span class="n">random_unitary</span>


<div class="viewcode-block" id="MPS"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS">[docs]</a><span class="k">class</span> <span class="nc">MPS</span><span class="p">(</span><span class="n">TensorNetwork</span><span class="p">):</span>  <span class="c1"># MARK: MPS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for Matrix Product States. This is the base class from which</span>
<span class="sd">    :class:`UMPS`, :class:`MPSLayer` and :class:`UMPSLayer` inherit.</span>
<span class="sd">    </span>
<span class="sd">    Matrix Product States are formed by:</span>
<span class="sd">    </span>
<span class="sd">    * ``mats_env``: Environment of `matrix` nodes with axes</span>
<span class="sd">      ``(&quot;left&quot;, &quot;input&quot;, &quot;right&quot;)``.</span>
<span class="sd">    </span>
<span class="sd">    * ``left_node``, ``right_node``: `Vector` nodes with axes ``(&quot;right&quot;,)``</span>
<span class="sd">      and ``(&quot;left&quot;,)``, respectively. These are used to close the boundary</span>
<span class="sd">      in the case ``boudary`` is ``&quot;obc&quot;``. Otherwise, both are ``None``.</span>
<span class="sd">    </span>
<span class="sd">    The base ``MPS`` class enables setting various nodes as either input or</span>
<span class="sd">    output nodes. This feature proves useful when computing marginal or</span>
<span class="sd">    conditional distributions. The assignment of roles can be altered</span>
<span class="sd">    dynamically, allowing input nodes to transition to output nodes, and vice</span>
<span class="sd">    versa.</span>
<span class="sd">    </span>
<span class="sd">    Input nodes will be connected to data nodes at their ``&quot;input&quot;`` edges, and</span>
<span class="sd">    contracted against them when calling :meth:`contract`. Output nodes, on the</span>
<span class="sd">    other hand, will remain disconnected. If ``marginalize_output = True`` in</span>
<span class="sd">    :meth:`contract`, the open indices of the output nodes can be marginalized</span>
<span class="sd">    so that the output is a single scalar (or a vector with only batch</span>
<span class="sd">    dimensions). If ``marginalize_output = False`` the result will be a tensor</span>
<span class="sd">    with as many dimensions as output nodes where in the MPS, plus the</span>
<span class="sd">    corresponding batch dimensions.</span>
<span class="sd">    </span>
<span class="sd">    If all input nodes have the same physical dimensions, the input data tensor</span>
<span class="sd">    can be passed as a single tensor. Otherwise, it would have to be passed as</span>
<span class="sd">    a list of tensors with different sizes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_features : int, optional</span>
<span class="sd">        Number of nodes that will be in ``mats_env``. That is, number of nodes</span>
<span class="sd">        without taking into account ``left_node`` and ``right_node``.</span>
<span class="sd">    phys_dim : int, list[int] or tuple[int], optional</span>
<span class="sd">        Physical dimension(s). If given as a sequence, its length should be</span>
<span class="sd">        equal to ``n_features``.</span>
<span class="sd">    bond_dim : int, list[int] or tuple[int], optional</span>
<span class="sd">        Bond dimension(s). If given as a sequence, its length should be equal</span>
<span class="sd">        to ``n_features`` (if ``boundary = &quot;pbc&quot;``) or ``n_features - 1`` (if</span>
<span class="sd">        ``boundary = &quot;obc&quot;``). The i-th bond dimension is always the dimension</span>
<span class="sd">        of the right edge of the i-th node.</span>
<span class="sd">    boundary : {&quot;obc&quot;, &quot;pbc&quot;}</span>
<span class="sd">        String indicating whether periodic or open boundary conditions should</span>
<span class="sd">        be used.</span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        Instead of providing ``n_features``, ``phys_dim``, ``bond_dim`` and</span>
<span class="sd">        ``boundary``, a list of MPS tensors can be provided. In such case, all</span>
<span class="sd">        mentioned attributes will be inferred from the given tensors. All</span>
<span class="sd">        tensors should be rank-3 tensors, with shape ``(bond_dim, phys_dim,</span>
<span class="sd">        bond_dim)``. If the first and last elements are rank-2 tensors, with</span>
<span class="sd">        shapes ``(phys_dim, bond_dim)``, ``(bond_dim, phys_dim)``, respectively,</span>
<span class="sd">        the inferred boundary conditions will be &quot;obc&quot;. Also, if ``tensors``</span>
<span class="sd">        contains a single element, it can be rank-1 (&quot;obc&quot;) or rank-3 (&quot;pbc&quot;).</span>
<span class="sd">    in_features: list[int] or tuple[int], optional</span>
<span class="sd">        List of indices indicating the positions of the MPS nodes that will be</span>
<span class="sd">        considered as input nodes. These nodes will have a neighbouring data</span>
<span class="sd">        node connected to its ``&quot;input&quot;`` edge when the :meth:`set_data_nodes`</span>
<span class="sd">        method is called. ``in_features`` is the complementary set of</span>
<span class="sd">        ``out_features``, so it is only required to specify one of them.</span>
<span class="sd">    out_features: list[int] or tuple[int], optional</span>
<span class="sd">        List of indices indicating the positions of the MPS nodes that will be</span>
<span class="sd">        considered as output nodes. These nodes will be left with their ``&quot;input&quot;``</span>
<span class="sd">        edges open when contrating the network. If ``marginalize_output`` is</span>
<span class="sd">        set to ``True`` in :meth:`contract`, the network will be connected to</span>
<span class="sd">        itself at these nodes, and contracted. ``out_features`` is the</span>
<span class="sd">        complementary set of ``in_features``, so it is only required to specify</span>
<span class="sd">        one of them.</span>
<span class="sd">    n_batches : int</span>
<span class="sd">        Number of batch edges of input ``data`` nodes. Usually ``n_batches = 1``</span>
<span class="sd">        (where the batch edge is used for the data batched) but it could also</span>
<span class="sd">        be ``n_batches = 2`` (one edge for data batched, other edge for image</span>
<span class="sd">        patches in convolutional layers).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ``MPS`` with the same physical dimensions:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps = tk.models.MPS(n_features=5,</span>
<span class="sd">    ...                     phys_dim=2,</span>
<span class="sd">    ...                     bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 5, 2) # batch_size x n_features x feature_size</span>
<span class="sd">    &gt;&gt;&gt; result = mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20])</span>
<span class="sd">    </span>
<span class="sd">    ``MPS`` with different physical dimensions:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps = tk.models.MPS(n_features=5,</span>
<span class="sd">    ...                     phys_dim=list(range(2, 7)),</span>
<span class="sd">    ...                     bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; data = [torch.ones(20, i)</span>
<span class="sd">    ...         for i in range(2, 7)] # n_features * [batch_size x feature_size]</span>
<span class="sd">    &gt;&gt;&gt; result = mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20])</span>
<span class="sd">    </span>
<span class="sd">    ``MPS`` can also be initialized from a list of tensors:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; tensors = [torch.randn(5, 2, 5) for _ in range(10)]</span>
<span class="sd">    &gt;&gt;&gt; mps = tk.models.MPS(tensors=tensors)</span>
<span class="sd">    </span>
<span class="sd">    If ``in_features``/``out_features`` are specified, data will only be</span>
<span class="sd">    connected to the input nodes, leaving output nodes open:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps = tk.models.MPS(tensors=tensors,</span>
<span class="sd">    ...                     out_features=[0, 3, 9])</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 7, 2) # batch_size x n_features x feature_size</span>
<span class="sd">    &gt;&gt;&gt; result = mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 2, 2, 2])</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps.reset()</span>
<span class="sd">    &gt;&gt;&gt; result = mps(data, marginalize_output=True)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">phys_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">in_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mps&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># boundary</span>
            <span class="k">if</span> <span class="n">boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obc&#39;</span><span class="p">,</span> <span class="s1">&#39;pbc&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`boundary` should be one of &quot;obc&quot; or &quot;pbc&quot;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="n">boundary</span>

            <span class="c1"># n_features</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be int type&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n_features</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be at least 1&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="n">n_features</span>

            <span class="c1"># phys_dim</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_features</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If `phys_dim` is given as a sequence of int, &#39;</span>
                                     <span class="s1">&#39;its length should be equal to `n_features`&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">phys_dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_features</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`phys_dim` should be int, tuple[int] or list[int] &#39;</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">)</span>

            <span class="c1"># bond_dim</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;If `bond_dim` is given as a sequence of int, and &#39;</span>
                            <span class="s1">&#39;`boundary` is &quot;obc&quot;, its length should be equal &#39;</span>
                            <span class="s1">&#39;to `n_features` - 1&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;pbc&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_features</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;If `bond_dim` is given as a sequence of int, and &#39;</span>
                            <span class="s1">&#39;`boundary` is &quot;pbc&quot;, its length should be equal &#39;</span>
                            <span class="s1">&#39;to `n_features`&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_dim</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;pbc&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_features</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`bond_dim` should be int, tuple[int] or list[int]&#39;</span>
                                <span class="s1">&#39; type&#39;</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a tuple[torch.Tensor] or &#39;</span>
                                <span class="s1">&#39;list[torch.Tensor] type&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a tuple[torch.Tensor]&#39;</span>
                                        <span class="s1">&#39; or list[torch.Tensor] type&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;The first and last elements in `tensors` &#39;</span>
                                <span class="s1">&#39;should be both rank-2 or rank-3 tensors. If&#39;</span>
                                <span class="s1">&#39; the first element is also the last one,&#39;</span>
                                <span class="s1">&#39; it should be a rank-1 tensor&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="s1">&#39;pbc&#39;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;The first and last elements in `tensors` &#39;</span>
                                <span class="s1">&#39;should have the same rank. Both should be &#39;</span>
                                <span class="s1">&#39;rank-2 or rank-3 tensors. If the first &#39;</span>
                                <span class="s1">&#39;element is also the last one, it should &#39;</span>
                                <span class="s1">&#39;be a rank-1 tensor&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="s1">&#39;If the first and last elements in `tensors`&#39;</span>
                                    <span class="s1">&#39; are rank-3 tensors, the first dimension &#39;</span>
                                    <span class="s1">&#39;of the first element should coincide with&#39;</span>
                                    <span class="s1">&#39; the last dimension of the last element&#39;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;The elements of `tensors` should be rank-3 &#39;</span>
                                <span class="s1">&#39;tensors, except the first and lest elements&#39;</span>
                                <span class="s1">&#39; if boundary is &quot;obc&quot;&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="c1"># in_features and out_features</span>
        <span class="k">if</span> <span class="n">in_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># By default, all nodes are input nodes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_features</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">out_f</span> <span class="ow">in</span> <span class="n">out_features</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_f</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out_features` should be tuple[int]&#39;</span>
                                            <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">out_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out_f</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Elements of `out_features` should&#39;</span>
                                             <span class="s1">&#39; be between 0 and (`n_features` - 1)&#39;</span><span class="p">)</span>
                    <span class="n">out_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                    <span class="n">in_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out_features` should be tuple[int]&#39;</span>
                                    <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">in_f</span> <span class="ow">in</span> <span class="n">in_features</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_f</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`in_features` should be tuple[int]&#39;</span>
                                        <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">in_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">in_f</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Elements in `in_features` should&#39;</span>
                                         <span class="s1">&#39;be between 0 and (`n_features` - 1)&#39;</span><span class="p">)</span>
                <span class="n">in_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`in_features` should be tuple[int]&#39;</span>
                                <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
                    
            <span class="k">if</span> <span class="n">out_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                <span class="n">union</span> <span class="o">=</span> <span class="n">in_features</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="n">in_features</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">union</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inter</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([])):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;If both `in_features` and `out_features` are provided,&#39;</span>
                        <span class="s1">&#39; they should be complementary. That is, the union should&#39;</span>
                        <span class="s1">&#39; be the total range 0, ..., (`n_features` - 1), and &#39;</span>
                        <span class="s1">&#39;the intersection should be empty&#39;</span><span class="p">)</span>
        
        <span class="c1"># n_batches</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_batches</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_batches` should be int type&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span> <span class="o">=</span> <span class="n">n_batches</span>
        
        <span class="c1"># Properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create Tensor Network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                        <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="c1"># ----------</span>
    <span class="c1"># Properties</span>
    <span class="c1"># ----------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns number of nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phys_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns physical dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns bond dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns boundary condition (&quot;obc&quot; or &quot;pbc&quot;).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of batch edges of the ``data`` nodes. To change this</span>
<span class="sd">        attribute, first call :meth:`~tensorkrowch.TensorNetwork.unset_data_nodes`</span>
<span class="sd">        if there are already data nodes in the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span>
    
    <span class="nd">@n_batches</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_batches</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_batches</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_nodes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`n_batches` cannot be changed if the MPS has data nodes. &#39;</span>
                    <span class="s1">&#39;Use unset_data_nodes first&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_batches</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_batches` should be int type&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span> <span class="o">=</span> <span class="n">n_batches</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of positions of the input nodes. To change this</span>
<span class="sd">        attribute, first call :meth:`~tensorkrowch.TensorNetwork.unset_data_nodes`</span>
<span class="sd">        if there are already data nodes in the network. When changing it,</span>
<span class="sd">        :attr:`out_features` will change accordingly to be the complementary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span>
    
    <span class="nd">@in_features</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">in_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_features</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`in_features` cannot be changed if the MPS has data nodes. &#39;</span>
                <span class="s1">&#39;Use unset_data_nodes first&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">in_f</span> <span class="ow">in</span> <span class="n">in_features</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_f</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`in_features` should be tuple[int]&#39;</span>
                                    <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">in_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">in_f</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Elements in `in_features` should&#39;</span>
                                     <span class="s1">&#39;be between 0 and (`n_features` - 1)&#39;</span><span class="p">)</span>
            <span class="n">in_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
            <span class="n">out_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;`in_features` should be tuple[int] or list[int] type&#39;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of positions of the output nodes. To change this</span>
<span class="sd">        attribute, first call :meth:`~tensorkrowch.TensorNetwork.unset_data_nodes`</span>
<span class="sd">        if there are already data nodes in the network. When changing it,</span>
<span class="sd">        :attr:`in_features` will change accordingly to be the complementary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span>
    
    <span class="nd">@out_features</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">out_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_nodes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`out_features` cannot be changed if the MPS has data nodes. &#39;</span>
                    <span class="s1">&#39;Use unset_data_nodes first&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_features</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">out_f</span> <span class="ow">in</span> <span class="n">out_features</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_f</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out_features` should be tuple[int]&#39;</span>
                                    <span class="s1">&#39; or list[int] type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">out_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out_f</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Elements in `out_features` should&#39;</span>
                                        <span class="s1">&#39;be between 0 and (`n_features` - 1)&#39;</span><span class="p">)</span>
            <span class="n">out_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
            <span class="n">in_features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_features</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_features</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;`out_features` should be tuple[int] or list[int] type&#39;</span><span class="p">)</span>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a list of lists of consecutive input positions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">split_sequence_into_regions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_regions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a list of lists of consecutive output positions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">split_sequence_into_regions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the ``left_node``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the ``right_node``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mats_env</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of nodes in ``mats_env``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_env</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of input nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_env</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of output nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">]</span>
    
    <span class="c1"># -------</span>
    <span class="c1"># Methods</span>
    <span class="c1"># -------</span>
    <span class="k">def</span> <span class="nf">_make_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates all the nodes of the MPS.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot create MPS nodes if the MPS already has &#39;</span>
                             <span class="s1">&#39;nodes&#39;</span><span class="p">)</span>
        
        <span class="n">aux_bond_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aux_bond_dim</span><span class="p">:</span>
                <span class="n">aux_bond_dim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">=</span> <span class="n">ParamNode</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">aux_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span>
                                        <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,),</span>
                                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;left_node&#39;</span><span class="p">,</span>
                                        <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span> <span class="o">=</span> <span class="n">ParamNode</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">aux_bond_dim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],),</span>
                                    <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,),</span>
                                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;right_node&#39;</span><span class="p">,</span>
                                    <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            
            <span class="n">aux_bond_dim</span> <span class="o">=</span> <span class="n">aux_bond_dim</span> <span class="o">+</span> <span class="p">[</span><span class="n">aux_bond_dim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">aux_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">ParamNode</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">aux_bond_dim</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                    <span class="n">aux_bond_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">),</span>
                             <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;mats_env_node_(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
                             <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;pbc&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">periodic_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">periodic_edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">_make_unitaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates random unitaries to initialize the MPS in canonical form with</span>
<span class="sd">        orthogonality center at the rightmost node.&quot;&quot;&quot;</span>
        <span class="n">tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">aux_shape</span> <span class="o">=</span> <span class="n">node_shape</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">aux_shape</span> <span class="o">=</span> <span class="n">node_shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">aux_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">aux_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">random_unitary</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">),</span> <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">)]</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">node_shape</span><span class="p">)</span>
            
            <span class="n">tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tensors</span>

<div class="viewcode-block" id="MPS.initialize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">init_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                   <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes all the nodes of the :class:`MPS`. It can be called when</span>
<span class="sd">        instantiating the model, or to override the existing nodes&#39; tensors.</span>
<span class="sd">        </span>
<span class="sd">        There are different methods to initialize the nodes:</span>
<span class="sd">        </span>
<span class="sd">        * ``{&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;}``: Each node is</span>
<span class="sd">          initialized calling :meth:`~tensorkrowch.AbstractNode.set_tensor` with</span>
<span class="sd">          the given method, ``device`` and ``kwargs``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;randn_eye&quot;``: Nodes are initialized as in this</span>
<span class="sd">          `paper &lt;https://arxiv.org/abs/1605.03795&gt;`_, adding identities at the</span>
<span class="sd">          top of random gaussian tensors. In this case, ``std`` should be</span>
<span class="sd">          specified with a low value, e.g., ``std = 1e-9``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;unit&quot;``: Nodes are initialized as random unitaries, so that the</span>
<span class="sd">          MPS is in canonical form, with the orthogonality center at the</span>
<span class="sd">          rightmost node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensors : list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">            Sequence of tensors to set in each of the MPS nodes. If ``boundary``</span>
<span class="sd">            is ``&quot;obc&quot;``, all tensors should be rank-3, except the first and</span>
<span class="sd">            last ones, which can be rank-2, or rank-1 (if the first and last are</span>
<span class="sd">            the same). If ``boundary`` is ``&quot;pbc&quot;``, all tensors should be</span>
<span class="sd">            rank-3.</span>
<span class="sd">        init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">            Initialization method.</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">        kwargs : float</span>
<span class="sd">            Keyword arguments for the different initialization methods. See</span>
<span class="sd">            :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span>
            <span class="n">tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_unitaries</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a sequence of `n_features`&#39;</span>
                                 <span class="s1">&#39; elements&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                <span class="n">tensors</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Left node</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">device</span><span class="o">=</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">aux_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                    
                    <span class="c1"># Right node</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">device</span><span class="o">=</span><span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">aux_tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                
            <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span>
                
        <span class="k">elif</span> <span class="n">init_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;randn_eye&#39;</span><span class="p">:</span>
                <span class="n">init_method</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span>
                <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">add_eye</span><span class="p">:</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="n">aux_tensor</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                     <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Left node</span>
                        <span class="n">aux_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Right node</span>
                        <span class="n">aux_tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span></div>

<div class="viewcode-block" id="MPS.set_data_nodes"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.set_data_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">set_data_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates ``data`` nodes and connects each of them to the ``&quot;input&quot;``</span>
<span class="sd">        edge of each input node.</span>
<span class="sd">        &quot;&quot;&quot;</span>      
        <span class="n">input_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_env</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_data_nodes</span><span class="p">(</span><span class="n">input_edges</span><span class="o">=</span><span class="n">input_edges</span><span class="p">,</span>
                               <span class="n">num_batch_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="MPS.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MPS&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`MPS`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied MPS should be</span>
<span class="sd">            set as the tensors in the current MPS (``True``), or cloned</span>
<span class="sd">            (``False``). In the former case, tensors in both MPS&#39;s will be</span>
<span class="sd">            the same, which might be useful if one needs more than one copy</span>
<span class="sd">            of an MPS, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MPS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">MPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span>
                      <span class="n">phys_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">,</span>
                      <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">,</span>
                      <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span>
                      <span class="n">tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">in_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="p">,</span>
                      <span class="n">out_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">,</span>
                      <span class="n">n_batches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">,</span>
                      <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_mps</span></div>
    
<div class="viewcode-block" id="MPS.parameterize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.parameterize">[docs]</a>    <span class="k">def</span> <span class="nf">parameterize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">set_param</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">override</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TensorNetwork&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes all nodes of the MPS. If there are ``resultant`` nodes</span>
<span class="sd">        in the MPS, it will be first :meth:`~tensorkrowch.TensorNetwork.reset`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        set_param : bool</span>
<span class="sd">            Boolean indicating whether the tensor network has to be parameterized</span>
<span class="sd">            (``True``) or de-parameterized (``False``).</span>
<span class="sd">        override : bool</span>
<span class="sd">            Boolean indicating whether the tensor network should be parameterized</span>
<span class="sd">            in-place (``True``) or copied and then parameterized (``False``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resultant_nodes</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Resultant nodes will be removed before parameterizing the TN&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">override</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">share_tensors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
            <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">net</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="n">net</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">_left_node</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
            <span class="n">net</span><span class="o">.</span><span class="n">_right_node</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">_right_node</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">net</span></div>

    <span class="k">def</span> <span class="nf">_input_contraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">nodes_env</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span>
                           <span class="n">inline_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
                                                       <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]],</span>
                                                       <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contracts input data nodes with MPS input nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inline_input</span><span class="p">:</span>
            <span class="n">mats_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contract</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_env</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mats_result</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodes_env</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">nodes_env</span><span class="p">)</span>
                <span class="n">stack_data</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_env</span><span class="p">])</span>

                <span class="n">stack</span> <span class="o">^</span> <span class="n">stack_data</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">stack_data</span> <span class="o">@</span> <span class="n">stack</span>
                <span class="n">mats_result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mats_result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inline_contraction</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">from_left</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contracts sequence of MPS nodes (matrices) inline.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">from_left</span><span class="p">:</span>
            <span class="n">result_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">result_node</span> <span class="o">@=</span> <span class="n">node</span>
            <span class="k">return</span> <span class="n">result_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">result_node</span> <span class="o">=</span> <span class="n">node</span> <span class="o">@</span> <span class="n">result_node</span>
            <span class="k">return</span> <span class="n">result_node</span>

    <span class="k">def</span> <span class="nf">_contract_envs_inline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mats_env</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contracts nodes environments inline.&quot;&quot;&quot;</span>
        <span class="n">from_left</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mats_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span><span class="p">:</span>
                <span class="n">mats_env</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span><span class="p">]</span> <span class="o">+</span> <span class="n">mats_env</span>
            <span class="k">if</span> <span class="n">mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span><span class="p">:</span>
                <span class="n">mats_env</span> <span class="o">=</span> <span class="n">mats_env</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span><span class="p">]</span>
                <span class="n">from_left</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_contraction</span><span class="p">(</span><span class="n">mats_env</span><span class="p">,</span> <span class="n">from_left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aux_pairwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span>
    <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contracts a sequence of MPS nodes (matrices) pairwise.&quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">half_length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">nice_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_length</span>

            <span class="n">even_nodes</span> <span class="o">=</span> <span class="n">aux_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nice_length</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">odd_nodes</span> <span class="o">=</span> <span class="n">aux_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nice_length</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">leftover</span> <span class="o">=</span> <span class="n">aux_nodes</span><span class="p">[</span><span class="n">nice_length</span><span class="p">:]</span>

            <span class="n">stack1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">even_nodes</span><span class="p">)</span>
            <span class="n">stack2</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">odd_nodes</span><span class="p">)</span>

            <span class="n">stack1</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">stack2</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>

            <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">stack1</span> <span class="o">@</span> <span class="n">stack2</span>
            <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">aux_nodes</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">aux_nodes</span><span class="p">,</span> <span class="n">leftover</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_pairwise_contraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mats_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Contracts nodes environments pairwise.&quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mats_nodes</span><span class="p">)</span>
        <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">mats_nodes</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">leftovers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">aux1</span><span class="p">,</span> <span class="n">aux2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_pairwise</span><span class="p">(</span><span class="n">aux_nodes</span><span class="p">)</span>
                <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">aux1</span>
                <span class="n">leftovers</span> <span class="o">=</span> <span class="n">aux2</span> <span class="o">+</span> <span class="n">leftovers</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux1</span><span class="p">)</span>

            <span class="n">aux_nodes</span> <span class="o">=</span> <span class="n">aux_nodes</span> <span class="o">+</span> <span class="n">leftovers</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pairwise_contraction</span><span class="p">(</span><span class="n">aux_nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_envs_inline</span><span class="p">(</span><span class="n">aux_nodes</span><span class="p">)</span>

<div class="viewcode-block" id="MPS.contract"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.contract">[docs]</a>    <span class="k">def</span> <span class="nf">contract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">inline_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">inline_mats</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">marginalize_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">embedding_matrices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
                                        <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                                              <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">mpo</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MPO</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contracts the whole MPS.</span>
<span class="sd">        </span>
<span class="sd">        If the MPS has input nodes, these are contracted against input ``data``</span>
<span class="sd">        nodes.</span>
<span class="sd">        </span>
<span class="sd">        If the MPS has output nodes, these can be left with their ``&quot;input&quot;``</span>
<span class="sd">        edges open, or can be marginalized, contracting the remaining output</span>
<span class="sd">        nodes with themselves, if the argument ``&quot;marginalize_output&quot;`` is set</span>
<span class="sd">        to ``True``.</span>
<span class="sd">        </span>
<span class="sd">        In the latter case, one can add additional nodes in between the MPS-MPS</span>
<span class="sd">        contraction:</span>
<span class="sd">        </span>
<span class="sd">        * ``embedding_matrices``: A list of matrices with appropiate physical</span>
<span class="sd">          dimensions can be passed, one for each output node. These matrices</span>
<span class="sd">          will connect the two ``&quot;input&quot;`` edges of the corresponding nodes.</span>
<span class="sd">        </span>
<span class="sd">        * ``mpo``: If an :class:`MPO` is passed, it is assumed that the output</span>
<span class="sd">          nodes of the MPS are already connected to the ``&quot;output&quot;`` edges of</span>
<span class="sd">          the MPO nodes, and that the MPO nodes have been moved to the MPS, so</span>
<span class="sd">          that all nodes belong to the MPS network. In this case, each MPO node</span>
<span class="sd">          will connect the two ``&quot;input&quot;`` edges of the corresponding MPS nodes.</span>
<span class="sd">          When calling ``mps(marginalize_output=True, mpo=mpo)``, this will</span>
<span class="sd">          perform the MPS-MPO-MPS contraction at the output nodes of the MPS.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inline_input : bool</span>
<span class="sd">            Boolean indicating whether input ``data`` nodes should be contracted</span>
<span class="sd">            with the ``MPS`` input nodes inline (one contraction at a time) or</span>
<span class="sd">            in a single stacked contraction.</span>
<span class="sd">        inline_mats : bool</span>
<span class="sd">            Boolean indicating whether the sequence of matrices (resultant</span>
<span class="sd">            after contracting the input ``data`` nodes) should be contracted</span>
<span class="sd">            inline or as a sequence of pairwise stacked contrations.</span>
<span class="sd">        marginalize_output : bool</span>
<span class="sd">            Boolean indicating whether output nodes should be marginalized. If</span>
<span class="sd">            ``True``, after contracting all the input nodes with their</span>
<span class="sd">            neighbouring data nodes, this resultant network is contracted with</span>
<span class="sd">            itself connecting output nodes to itselves at ``&quot;input&quot;`` edges. If</span>
<span class="sd">            ``False``, output nodes are left with their ``&quot;input&quot;`` edges</span>
<span class="sd">            disconnected.</span>
<span class="sd">        embedding_matrices : torch.Tensor, list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">            If ``marginalize_output = True``, a matrix can be introduced</span>
<span class="sd">            between each output node and its copy, connecting the ``&quot;input&quot;``</span>
<span class="sd">            edges. This can be useful when data vectors are not represented</span>
<span class="sd">            as qubits in the computational basis, but are transformed via</span>
<span class="sd">            some :ref:`Embeddings` function.</span>
<span class="sd">        mpo : MPO, optional</span>
<span class="sd">            MPO that is to be contracted with the MPS at the output nodes, if</span>
<span class="sd">            ``marginalize_output = True``. To do that, in contrast with how</span>
<span class="sd">            ``embedding_matrices`` works, the MPS has to be already connected</span>
<span class="sd">            to the MPO (at the output nodes). That is, the ``&quot;output&quot;`` edges</span>
<span class="sd">            of the MPO nodes should be connected to the ``&quot;input&quot;`` edges of</span>
<span class="sd">            the MPS output nodes. If there are no input nodes, the MPS-MPO-MPS</span>
<span class="sd">            is performed by calling ``mps(marginalize_output=True, mpo=mpo)``,</span>
<span class="sd">            without passing extra data tensors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">embedding_matrices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">embedding_matrices</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">embedding_matrices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;`embedding_matrices` should have the same amount of &#39;</span>
                        <span class="s1">&#39;elements as output nodes are in the MPS&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">embedding_matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">embedding_matrices</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">embedding_matrices</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">out_env</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;`embedding_matrices` should be torch.Tensor type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;`embedding_matrices should ne rank-2 tensors&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;`embedding_matrices` should have equal dimensions&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;`embedding_matrices` dimensions should be equal &#39;</span>
                        <span class="s1">&#39;to the input dimensions of the corresponding MPS &#39;</span>
                        <span class="s1">&#39;output nodes&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mpo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mpo</span><span class="p">,</span> <span class="n">MPO</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`mpo` should be MPO type&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mpo</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`mpo` should have as many features as output nodes are &#39;</span>
                    <span class="s1">&#39;in the MPS&#39;</span><span class="p">)</span>
            
        <span class="n">in_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_regions</span>
        <span class="n">out_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_regions</span>
        
        <span class="n">mats_in_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_contraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_env</span><span class="p">,</span> <span class="n">inline_input</span><span class="p">)</span>
        
        <span class="n">in_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">in_regions</span><span class="p">:</span>      
            <span class="k">if</span> <span class="n">inline_mats</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_envs_inline</span><span class="p">(</span><span class="n">mats_in_env</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pairwise_contraction</span><span class="p">(</span><span class="n">mats_in_env</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)])</span>
            
            <span class="n">mats_in_env</span> <span class="o">=</span> <span class="n">mats_in_env</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">):]</span>
            <span class="n">in_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out_regions</span><span class="p">:</span>
            <span class="c1"># If there is only input region, in_results has only 1 node</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">in_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Contract each in_result with the next output node</span>
            <span class="n">nodes_out_env</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">out_first</span> <span class="o">=</span> <span class="n">out_regions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">out_last</span> <span class="o">=</span> <span class="n">out_regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_regions</span><span class="p">)):</span>
                <span class="n">aux_out_env</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">out_regions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">out_first</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                        <span class="n">aux_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">@</span> <span class="n">aux_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_results</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">out_first</span><span class="p">]</span> <span class="o">@</span> <span class="n">aux_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="n">nodes_out_env</span> <span class="o">+=</span> <span class="n">aux_out_env</span>
            
            <span class="k">if</span> <span class="n">out_last</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">):</span>
                    <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">in_results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">marginalize_output</span><span class="p">:</span>
                <span class="c1"># Contract all output nodes sequentially</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_contraction</span><span class="p">(</span><span class="n">nodes_out_env</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Copy output nodes sharing tensors</span>
                <span class="n">copied_nodes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_out_env</span><span class="p">:</span>
                    <span class="n">new_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span>
                                              <span class="n">axes_names</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">axes_names</span><span class="p">,</span>
                                              <span class="n">name</span><span class="o">=</span><span class="s1">&#39;virtual_result_copy&#39;</span><span class="p">,</span>
                                              <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">virtual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">new_node</span><span class="o">.</span><span class="n">set_tensor_from</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">copied_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                
                <span class="c1"># Connect with neighbours</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copied_nodes</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;pbc&#39;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_connected_to</span><span class="p">(</span><span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                            <span class="n">copied_nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">copied_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">copied_nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">copied_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
                
                <span class="c1"># Contract with embedding matrices</span>
                <span class="k">if</span> <span class="n">embedding_matrices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes_out_env</span><span class="p">):</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">reattach_edges</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">])</span>
                        <span class="n">mat_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">embedding_matrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">),</span>
                                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;virtual_result_mat&#39;</span><span class="p">,</span>
                                        <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">virtual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">mat_node</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
                        <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat_node</span> <span class="o">@</span> <span class="n">node</span>
                
                <span class="c1"># Contract with mpo</span>
                <span class="k">elif</span> <span class="n">mpo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_out_env</span><span class="p">)):</span>
                        <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">mpo</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    
                    <span class="k">if</span> <span class="n">mpo</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                        <span class="n">nodes_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">@</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">mpo</span><span class="o">.</span><span class="n">_right_node</span>
                
                <span class="c1"># Reattach input edges of resultant output nodes and connect</span>
                <span class="c1"># with copied nodes</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copied_nodes</span><span class="p">)):</span>
                    <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reattach_edges</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">])</span>
                    <span class="n">copied_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">nodes_out_env</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
                
                <span class="c1"># Contract all output_nodes</span>
                <span class="n">mats_out_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_contraction</span><span class="p">(</span><span class="n">nodes_out_env</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_contraction</span><span class="p">(</span><span class="n">mats_out_env</span><span class="p">)</span>
            
        <span class="c1"># Contract periodic edge</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_connected_to</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">@=</span> <span class="n">result</span>
        
        <span class="c1"># Put batch edges in first positions</span>
        <span class="n">batch_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_batch</span><span class="p">():</span>
                <span class="n">batch_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="n">all_edges</span> <span class="o">=</span> <span class="n">batch_edges</span> <span class="o">+</span> <span class="n">other_edges</span>
        <span class="k">if</span> <span class="n">all_edges</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_edges</span><span class="p">))):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_edges</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="MPS.norm"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the norm of the MPS. This method internally sets</span>
<span class="sd">        ``in_features = []``, and calls the</span>
<span class="sd">        :meth:`~tensorkrowch.TensorNetwork.forward` method with</span>
<span class="sd">        ``marginalize_output = True``. Therefore, it may alter the behaviour</span>
<span class="sd">        of the MPS if it is not :meth:`~tensorkrowch.TensorNetwork.reset`</span>
<span class="sd">        afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unset_data_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_features</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">marginalize_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MPS.canonicalize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.canonicalize">[docs]</a>    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">canonicalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">oc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">mode</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;svd&#39;</span><span class="p">,</span>
                     <span class="n">rank</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cum_percentage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">renormalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns MPS into canonical form via local SVD/QR decompositions.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oc : int</span>
<span class="sd">            Position of the orthogonality center. It should be between 0 and </span>
<span class="sd">            ``n_features -1``.</span>
<span class="sd">        mode : {&quot;svd&quot;, &quot;svdr&quot;, &quot;qr&quot;}</span>
<span class="sd">            Indicates which decomposition should be used to split a node after</span>
<span class="sd">            contracting it. See more at :func:`~tensorkrowch.svd_`,</span>
<span class="sd">            :func:`~tensorkrowch.svdr_`, :func:`~tensorkrowch.qr_`.</span>
<span class="sd">            If mode is &quot;qr&quot;, operation :func:`~tensorkrowch.qr_` will be</span>
<span class="sd">            performed on nodes at the left of the output node, whilst operation</span>
<span class="sd">            :func:`~tensorkrowch.rq_` will be used for nodes at the right.</span>
<span class="sd">        rank : int, optional</span>
<span class="sd">            Number of singular values to keep.</span>
<span class="sd">        cum_percentage : float, optional</span>
<span class="sd">            Proportion that should be satisfied between the sum of all singular</span>
<span class="sd">            values kept and the total sum of all singular values.</span>
<span class="sd">            </span>
<span class="sd">            .. math::</span>
<span class="sd">            </span>
<span class="sd">                \frac{\sum_{i \in \{kept\}}{s_i}}{\sum_{i \in \{all\}}{s_i}} \ge</span>
<span class="sd">                cum\_percentage</span>
<span class="sd">        cutoff : float, optional</span>
<span class="sd">            Quantity that lower bounds singular values in order to be kept.</span>
<span class="sd">        renormalize : bool</span>
<span class="sd">            Indicates whether nodes should be renormalized after SVD/QR</span>
<span class="sd">            decompositions. If not, it may happen that the norm explodes as it</span>
<span class="sd">            is being accumulated from all nodes. Renormalization aims to avoid</span>
<span class="sd">            this undesired behavior by extracting the norm of each node on a</span>
<span class="sd">            logarithmic scale after SVD/QR decompositions are computed. Finally,</span>
<span class="sd">            the normalization factor is evenly distributed among all nodes of</span>
<span class="sd">            the MPS.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mps = tk.models.MPS(n_features=4,</span>
<span class="sd">        ...                     phys_dim=2,</span>
<span class="sd">        ...                     bond_dim=5)</span>
<span class="sd">        &gt;&gt;&gt; mps.canonicalize(rank=3)</span>
<span class="sd">        &gt;&gt;&gt; mps.bond_dim</span>
<span class="sd">        [3, 3, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="n">prev_auto_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_stack</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">oc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">oc</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Orthogonality center position `oc` should be &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">log_norm</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;svd&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">svd_</span><span class="p">(</span>
                    <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>
                    <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
                    <span class="n">cum_percentage</span><span class="o">=</span><span class="n">cum_percentage</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;svdr&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">svdr_</span><span class="p">(</span>
                    <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>
                    <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
                    <span class="n">cum_percentage</span><span class="o">=</span><span class="n">cum_percentage</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">qr_</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`mode` can only be &quot;svd&quot;, &quot;svdr&quot; or &quot;qr&quot;&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">renormalize</span><span class="p">:</span>
                <span class="n">aux_norm</span> <span class="o">=</span> <span class="n">result2</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">result2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">aux_norm</span><span class="o">.</span><span class="n">isinf</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">aux_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">result2</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">result2</span><span class="o">.</span><span class="n">tensor</span> <span class="o">/</span> <span class="n">aux_norm</span>
                    <span class="n">log_norm</span> <span class="o">+=</span> <span class="n">aux_norm</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>

            <span class="n">result1</span> <span class="o">=</span> <span class="n">result1</span><span class="o">.</span><span class="n">parameterize</span><span class="p">()</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result1</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">result2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;svd&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">svd_</span><span class="p">(</span>
                    <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                    <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
                    <span class="n">cum_percentage</span><span class="o">=</span><span class="n">cum_percentage</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;svdr&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">svdr_</span><span class="p">(</span>
                    <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                    <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
                    <span class="n">cum_percentage</span><span class="o">=</span><span class="n">cum_percentage</span><span class="p">,</span>
                    <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rq_</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`mode` can only be &quot;svd&quot;, &quot;svdr&quot; or &quot;qr&quot;&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">renormalize</span><span class="p">:</span>
                <span class="n">aux_norm</span> <span class="o">=</span> <span class="n">result1</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">result1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">aux_norm</span><span class="o">.</span><span class="n">isinf</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">aux_norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">result1</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">result1</span><span class="o">.</span><span class="n">tensor</span> <span class="o">/</span> <span class="n">aux_norm</span>
                    <span class="n">log_norm</span> <span class="o">+=</span> <span class="n">aux_norm</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>

            <span class="n">result2</span> <span class="o">=</span> <span class="n">result2</span><span class="o">.</span><span class="n">parameterize</span><span class="p">()</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result2</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">result1</span>

        <span class="n">nodes</span><span class="p">[</span><span class="n">oc</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">oc</span><span class="p">]</span><span class="o">.</span><span class="n">parameterize</span><span class="p">()</span>
        
        <span class="c1"># Rescale</span>
        <span class="k">if</span> <span class="n">log_norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_norm</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">renormalize</span> <span class="ow">and</span> <span class="p">(</span><span class="n">log_norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">*</span> <span class="n">rescale</span>
        
        <span class="c1"># Update variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span> <span class="o">=</span> <span class="n">nodes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">auto_stack</span> <span class="o">=</span> <span class="n">prev_auto_stack</span></div>

    <span class="k">def</span> <span class="nf">_project_to_bond_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">],</span>
                             <span class="n">bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">side</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projects all nodes into a space of dimension ``bond_dim``.&quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">device</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">!=</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`side` can only be </span><span class="se">\&#39;</span><span class="s1">left</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">right</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">is_dangling</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">))</span>

        <span class="n">line_mat_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">phys_dim_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">proj_mat_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="n">phys_dim_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">bond_dim</span> <span class="o">&lt;=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">():</span>
                <span class="n">proj_mat_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">phys_dim_lst</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">),</span>
                                     <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)),</span>
                                                 <span class="s1">&#39;bond_dim&#39;</span><span class="p">),</span>
                                     <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;proj_mat_node_</span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                     <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

                <span class="n">proj_mat_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">.</span><span class="n">int</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                    <span class="n">bond_dim</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">phys_dim_lst</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">proj_mat_node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

                <span class="n">aux_result</span> <span class="o">=</span> <span class="n">proj_mat_node</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">aux_result</span> <span class="o">@=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">line_mat_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_result</span><span class="p">)</span>  <span class="c1"># bond_dim x left x right</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">proj_mat_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bond_dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">.</span><span class="n">int</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">proj_mat_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">phys_dim_lst</span><span class="p">,</span> <span class="n">bond_dim</span><span class="p">),</span>
                                 <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)),</span>
                                             <span class="s1">&#39;bond_dim&#39;</span><span class="p">),</span>
                                 <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;proj_mat_node_</span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                 <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

            <span class="n">proj_mat_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">phys_dim_lst</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">.</span><span class="n">int</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                <span class="n">bond_dim</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">phys_dim_lst</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">proj_mat_node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">aux_result</span> <span class="o">=</span> <span class="n">proj_mat_node</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">aux_result</span> <span class="o">@=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">line_mat_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_result</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">phys_dim</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="n">proj_vec_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">,),</span>
                                 <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,),</span>
                                 <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;proj_vec_node_</span><span class="si">{</span><span class="n">side</span><span class="si">}</span><span class="s1">_(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">,</span>
                                 <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

            <span class="n">proj_vec_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">proj_vec_node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
            <span class="n">line_mat_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj_vec_node</span> <span class="o">@</span> <span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">line_mat_nodes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">line_mat_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">line_mat_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">@=</span> <span class="n">node</span>

        <span class="k">return</span> <span class="n">result</span>  <span class="c1"># bond_dim x left/right</span>

    <span class="k">def</span> <span class="nf">_aux_canonicalize_univocal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractNode</span><span class="p">],</span>
                                   <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                   <span class="n">left_nodeL</span><span class="p">:</span> <span class="n">AbstractNode</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns canonicalized version of the tensor at site ``idx``.&quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="c1"># left x input x right</span>
        <span class="n">left_nodeC</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># bond_dim[-1] x input  x right  /  bond_dim[-1] x input</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">left_nodeL</span> <span class="o">@</span> <span class="n">L</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">tensor</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">bond_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">prod_phys_left</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">prod_phys_left</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">bond_dim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">,</span> <span class="n">prod_phys_left</span><span class="p">)</span>

            <span class="n">prod_phys_right</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
                <span class="n">prod_phys_right</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">bond_dim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">,</span> <span class="n">prod_phys_right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bond_dim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_dim</span>

            <span class="n">left_nodeC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_to_bond_dim</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">[:</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                                   <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                                                   <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>  <span class="c1"># bond_dim x right</span>
            <span class="n">right_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_to_bond_dim</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span>
                                                   <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                                                   <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>  <span class="c1"># bond_dim x left</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">left_nodeC</span> <span class="o">@</span> <span class="n">right_node</span>  <span class="c1"># bond_dim x bond_dim</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">@=</span> <span class="n">right_node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">t</span><span class="p">()</span>  <span class="c1"># input x bond_dim</span>
                <span class="n">L</span> <span class="o">@=</span> <span class="n">C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape_L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span>
                <span class="c1"># (bond_dim[-1] * input) x bond_dim</span>
                <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">@</span> <span class="n">right_node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">t</span><span class="p">())</span>
                <span class="n">L</span> <span class="o">@=</span> <span class="n">C</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">shape_L</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">left_nodeC</span>

<div class="viewcode-block" id="MPS.canonicalize_univocal"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPS.canonicalize_univocal">[docs]</a>    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">canonicalize_univocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns MPS into the univocal canonical form defined `here</span>
<span class="sd">        &lt;https://arxiv.org/abs/2202.12319&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">!=</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`canonicalize_univocal` can only be used if &#39;</span>
                             <span class="s1">&#39;boundary is `obc`&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="n">prev_auto_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_stack</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">is_dangling</span><span class="p">():</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span> <span class="o">@</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reattach_edges</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">])</span>
            
            <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span>
            <span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reattach_edges</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">])</span>

        <span class="n">new_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">left_nodeC</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
            <span class="n">tensor</span><span class="p">,</span> <span class="n">left_nodeC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_canonicalize_univocal</span><span class="p">(</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
                <span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">left_nodeL</span><span class="o">=</span><span class="n">left_nodeC</span><span class="p">)</span>
            <span class="n">new_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
                    <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">change_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">is_dangling</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tensors</span><span class="o">=</span><span class="n">new_tensors</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data_node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">^</span> <span class="n">data_node</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">auto_stack</span> <span class="o">=</span> <span class="n">prev_auto_stack</span></div></div>


<div class="viewcode-block" id="UMPS"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPS">[docs]</a><span class="k">class</span> <span class="nc">UMPS</span><span class="p">(</span><span class="n">MPS</span><span class="p">):</span>  <span class="c1"># MARK: UMPS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for Uniform (translationally invariant) Matrix Product States. It is</span>
<span class="sd">    the uniform version of :class:`MPS`, that is, all nodes share the same</span>
<span class="sd">    tensor. Thus this class cannot have different physical or bond dimensions</span>
<span class="sd">    for each node, and boundary conditions are always periodic (``&quot;pbc&quot;``).</span>
<span class="sd">    </span>
<span class="sd">    |</span>
<span class="sd">    </span>
<span class="sd">    For a more detailed list of inherited properties and methods,</span>
<span class="sd">    check :class:`MPS`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_features : int</span>
<span class="sd">        Number of nodes that will be in ``mats_env``.</span>
<span class="sd">    phys_dim : int, optional</span>
<span class="sd">        Physical dimension.</span>
<span class="sd">    bond_dim : int, optional</span>
<span class="sd">        Bond dimension.</span>
<span class="sd">    tensor: torch.Tensor, optional</span>
<span class="sd">        Instead of providing ``phys_dim`` and ``bond_dim``, a single tensor</span>
<span class="sd">        can be provided. ``n_features`` is still needed to specify how many</span>
<span class="sd">        times the tensor should be used to form a finite MPS. The tensor</span>
<span class="sd">        should be rank-3, with its first and last dimensions being equal.</span>
<span class="sd">    in_features: list[int] or tuple[int], optional</span>
<span class="sd">        List of indices indicating the positions of the MPS nodes that will be</span>
<span class="sd">        considered as input nodes. These nodes will have a neighbouring data</span>
<span class="sd">        node connected to its ``&quot;input&quot;`` edge when the :meth:`set_data_nodes`</span>
<span class="sd">        method is called. ``in_features`` is the complementary set of</span>
<span class="sd">        ``out_features``, so it is only required to specify one of them.</span>
<span class="sd">    out_features: list[int] or tuple[int], optional</span>
<span class="sd">        List of indices indicating the positions of the MPS nodes that will be</span>
<span class="sd">        considered as output nodes. These nodes will be left with their ``&quot;input&quot;``</span>
<span class="sd">        edges open when contrating the network. If ``marginalize_output`` is</span>
<span class="sd">        set to ``True`` in :meth:`contract`, the network will be connected to</span>
<span class="sd">        itself at these nodes, and contracted. ``out_features`` is the</span>
<span class="sd">        complementary set of ``in_features``, so it is only required to specify</span>
<span class="sd">        one of them.</span>
<span class="sd">    n_batches : int</span>
<span class="sd">        Number of batch edges of input ``data`` nodes. Usually ``n_batches = 1``</span>
<span class="sd">        (where the batch edge is used for the data batched) but it could also</span>
<span class="sd">        be ``n_batches = 2`` (one edge for data batched, other edge for image</span>
<span class="sd">        patches in convolutional layers).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mps = tk.models.UMPS(n_features=4,</span>
<span class="sd">    ...                      phys_dim=2,</span>
<span class="sd">    ...                      bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; for node in mps.mats_env:</span>
<span class="sd">    ...     assert node.tensor_address() == &#39;virtual_uniform&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 4, 2) # batch_size x n_features x feature_size</span>
<span class="sd">    &gt;&gt;&gt; result = mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">phys_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">tensor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">in_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">tensors</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># n_features</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be int type&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_features</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be at least 1&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">tensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># phys_dim</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">phys_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`phys_dim` should be int type&#39;</span><span class="p">)</span>

            <span class="c1"># bond_dim</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bond_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`bond_dim` should be int type&#39;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tensor` should be torch.Tensor type&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tensor` should be a rank-3 tensor&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tensor` first and last dimensions should&#39;</span>
                                 <span class="s1">&#39; be equal so that the MPS can have &#39;</span>
                                 <span class="s1">&#39;periodic boundary conditions&#39;</span><span class="p">)</span>
            
            <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_features</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
                         <span class="n">phys_dim</span><span class="o">=</span><span class="n">phys_dim</span><span class="p">,</span>
                         <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                         <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span>
                         <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                         <span class="n">in_features</span><span class="o">=</span><span class="n">in_features</span><span class="p">,</span>
                         <span class="n">out_features</span><span class="o">=</span><span class="n">out_features</span><span class="p">,</span>
                         <span class="n">n_batches</span><span class="o">=</span><span class="n">n_batches</span><span class="p">,</span>
                         <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                         <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;umps&#39;</span>

    <span class="k">def</span> <span class="nf">_make_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates all the nodes of the MPS.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_make_nodes</span><span class="p">()</span>
        
        <span class="c1"># Virtual node</span>
        <span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">ParamNode</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                   <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">),</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;virtual_uniform&#39;</span><span class="p">,</span>
                                   <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">virtual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">uniform_memory</span>
        
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">set_tensor_from</span><span class="p">(</span><span class="n">uniform_memory</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_make_unitaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes MPS in canonical form.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span>
        <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">aux_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">random_unitary</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">),</span> <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">)]</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">node_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensor</span>

<div class="viewcode-block" id="UMPS.initialize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPS.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">init_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                   <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the common tensor of the :class:`UMPS`. It can be called</span>
<span class="sd">        when instantiating the model, or to override the existing nodes&#39; tensors.</span>
<span class="sd">        </span>
<span class="sd">        There are different methods to initialize the nodes:</span>
<span class="sd">        </span>
<span class="sd">        * ``{&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;}``: The tensor is</span>
<span class="sd">          initialized calling :meth:`~tensorkrowch.AbstractNode.set_tensor` with</span>
<span class="sd">          the given method, ``device`` and ``kwargs``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;randn_eye&quot;``: Tensor is initialized as in this</span>
<span class="sd">          `paper &lt;https://arxiv.org/abs/1605.03795&gt;`_, adding identities at the</span>
<span class="sd">          top of a random gaussian tensor. In this case, ``std`` should be</span>
<span class="sd">          specified with a low value, e.g., ``std = 1e-9``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;unit&quot;``: Tensor is initialized as a random unitary, so that the</span>
<span class="sd">          MPS is in canonical form.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensors : list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">            Sequence of a single tensor to set in each of the MPS nodes. The</span>
<span class="sd">            tensor should be rank-3, with its first and last dimensions being</span>
<span class="sd">            equal.</span>
<span class="sd">        init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">            Initialization method.</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">        kwargs : float</span>
<span class="sd">            Keyword arguments for the different initialization methods. See</span>
<span class="sd">            :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span>
        
        <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span>
            <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_unitaries</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">elif</span> <span class="n">init_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;randn_eye&#39;</span><span class="p">:</span>
                <span class="n">init_method</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span>
                <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="n">node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add_eye</span><span class="p">:</span>
                <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                <span class="n">aux_tensor</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                 <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span></div>
    
<div class="viewcode-block" id="UMPS.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPS.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;UMPS&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`UMPS`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether the common tensor in the copied UMPS</span>
<span class="sd">            should be set as the tensor in the current UMPS (``True``), or</span>
<span class="sd">            cloned (``False``). In the former case, the tensor in both UMPS&#39;s</span>
<span class="sd">            will be the same, which might be useful if one needs more than one</span>
<span class="sd">            copy of a UMPS, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UMPS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">UMPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span>
                       <span class="n">phys_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">in_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_features</span><span class="p">,</span>
                       <span class="n">out_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_features</span><span class="p">,</span>
                       <span class="n">n_batches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">,</span>
                       <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_mps</span></div>
    
<div class="viewcode-block" id="UMPS.parameterize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPS.parameterize">[docs]</a>    <span class="k">def</span> <span class="nf">parameterize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">set_param</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">override</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TensorNetwork&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes all nodes of the MPS. If there are ``resultant`` nodes</span>
<span class="sd">        in the MPS, it will be first :meth:`~tensorkrowch.TensorNetwork.reset`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        set_param : bool</span>
<span class="sd">            Boolean indicating whether the tensor network has to be parameterized</span>
<span class="sd">            (``True``) or de-parameterized (``False``).</span>
<span class="sd">        override : bool</span>
<span class="sd">            Boolean indicating whether the tensor network should be parameterized</span>
<span class="sd">            in-place (``True``) or copied and then parameterized (``False``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resultant_nodes</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Resultant nodes will be removed before parameterizing the TN&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">override</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">share_tensors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
            <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
        
        <span class="c1"># It is important that uniform_memory is parameterized after the rest</span>
        <span class="c1"># of the nodes</span>
        <span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
        
        <span class="c1"># Tensor addresses have to be reassigned to reference</span>
        <span class="c1"># the uniform memory</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">set_tensor_from</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">net</span></div>
    
    <span class="k">def</span> <span class="nf">canonicalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">oc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">mode</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;svd&#39;</span><span class="p">,</span>
                     <span class="n">rank</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cum_percentage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">renormalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;`canonicalize` not implemented for UMPS&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">canonicalize_univocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;`canonicalize_univocal` not implemented for UMPS&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MPSLayer"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPSLayer">[docs]</a><span class="k">class</span> <span class="nc">MPSLayer</span><span class="p">(</span><span class="n">MPS</span><span class="p">):</span>  <span class="c1"># MARK: MPSLayer</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for Matrix Product States with a single output node. That is, this</span>
<span class="sd">    MPS has :math:`n` nodes, being :math:`n-1` input nodes connected to ``data``</span>
<span class="sd">    nodes (nodes that will contain the data tensors), and one output node,</span>
<span class="sd">    whose physical dimension (``out_dim``) is used as the label (for</span>
<span class="sd">    classification tasks).</span>
<span class="sd">    </span>
<span class="sd">    Besides, since this class has an output edge, when contracting the whole</span>
<span class="sd">    tensor network (with input data), the result will be a vector that can be</span>
<span class="sd">    plugged into the next layer (being this other tensor network or a neural</span>
<span class="sd">    network layer).</span>
<span class="sd">    </span>
<span class="sd">    If the physical dimensions of all the input nodes (``in_dim``) are equal,</span>
<span class="sd">    the input data tensor can be passed as a single tensor. Otherwise, it would</span>
<span class="sd">    have to be passed as a list of tensors with different sizes.</span>
<span class="sd">    </span>
<span class="sd">    |</span>
<span class="sd">    </span>
<span class="sd">    That is, ``MPSLayer`` is equivalent to :class:`MPS` with</span>
<span class="sd">    ``out_features = [out_position]``. However, ``in_features`` and</span>
<span class="sd">    ``out_features`` are still free to be changed if necessary, even though</span>
<span class="sd">    this may change the expected behaviour of the ``MPSLayer``. The expected</span>
<span class="sd">    behaviour can be recovered by setting ``out_features = [out_position]``</span>
<span class="sd">    again.</span>
<span class="sd">    </span>
<span class="sd">    |</span>
<span class="sd">    </span>
<span class="sd">    For a more detailed list of inherited properties and methods,</span>
<span class="sd">    check :class:`MPS`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_features : int, optional</span>
<span class="sd">        Number of nodes that will be in ``mats_env``. That is, number of nodes</span>
<span class="sd">        without taking into account ``left_node`` and ``right_node``. This also</span>
<span class="sd">        includes the output node, so if one wants to instantiate an ``MPSLayer``</span>
<span class="sd">        for a dataset with ``n`` features, it should be ``n_features = n + 1``,</span>
<span class="sd">        to account for the output node.</span>
<span class="sd">    in_dim : int, list[int] or tuple[int], optional</span>
<span class="sd">        Input dimension(s). Equivalent to the physical dimension(s) but only</span>
<span class="sd">        for input nodes. If given as a sequence, its length should be equal to</span>
<span class="sd">        ``n_features - 1``, since these are the input dimensions of the input</span>
<span class="sd">        nodes.</span>
<span class="sd">    out_dim : int, optional</span>
<span class="sd">        Output dimension (labels) for the output node. Equivalent to the</span>
<span class="sd">        physical dimension of the output node.</span>
<span class="sd">    bond_dim : int, list[int] or tuple[int], optional</span>
<span class="sd">        Bond dimension(s). If given as a sequence, its length should be equal</span>
<span class="sd">        to ``n_features`` (if ``boundary = &quot;pbc&quot;``) or ``n_features - 1`` (if</span>
<span class="sd">        ``boundary = &quot;obc&quot;``). The i-th bond dimension is always the dimension</span>
<span class="sd">        of the right edge of the i-th node (including output node).</span>
<span class="sd">    out_position : int, optional</span>
<span class="sd">        Position of the output node (label). Should be between 0 and</span>
<span class="sd">        ``n_features - 1``. If ``None``, the output node will be located at the</span>
<span class="sd">        middle of the MPS.</span>
<span class="sd">    boundary : {&quot;obc&quot;, &quot;pbc&quot;}</span>
<span class="sd">        String indicating whether periodic or open boundary conditions should</span>
<span class="sd">        be used.</span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        Instead of providing ``n_features``, ``in_dim``, ``out_dim``,</span>
<span class="sd">        ``bond_dim`` and ``boundary``, a list of MPS tensors can be provided.</span>
<span class="sd">        In such case, all mentioned attributes will be inferred from the given</span>
<span class="sd">        tensors. All tensors should be rank-3 tensors, with shape ``(bond_dim,</span>
<span class="sd">        phys_dim, bond_dim)``. If the first and last elements are rank-2 tensors,</span>
<span class="sd">        with shapes ``(phys_dim, bond_dim)``, ``(bond_dim, phys_dim)``,</span>
<span class="sd">        respectively, the inferred boundary conditions will be &quot;obc&quot;. Also, if</span>
<span class="sd">        ``tensors`` contains a single element, it can be rank-1 (&quot;obc&quot;) or</span>
<span class="sd">        rank-3 (&quot;pbc&quot;).</span>
<span class="sd">    n_batches : int</span>
<span class="sd">        Number of batch edges of input ``data`` nodes. Usually ``n_batches = 1``</span>
<span class="sd">        (where the batch edge is used for the data batched) but it could also</span>
<span class="sd">        be ``n_batches = 2`` (e.g. one edge for data batched, other edge for</span>
<span class="sd">        image patches in convolutional layers).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ``MPSLayer`` with same input dimensions:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps_layer = tk.models.MPSLayer(n_features=4,</span>
<span class="sd">    ...                                in_dim=2,</span>
<span class="sd">    ...                                out_dim=10,</span>
<span class="sd">    ...                                bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 3, 2) # batch_size x (n_features - 1) x feature_size</span>
<span class="sd">    &gt;&gt;&gt; result = mps_layer(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 10])</span>
<span class="sd">    </span>
<span class="sd">    ``MPSLayer`` with different input dimensions:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; mps_layer = tk.models.MPSLayer(n_features=4,</span>
<span class="sd">    ...                                in_dim=list(range(2, 5)),</span>
<span class="sd">    ...                                out_dim=10,</span>
<span class="sd">    ...                                bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; data = [torch.ones(20, i)</span>
<span class="sd">    ...         for i in range(2, 5)] # (n_features - 1) * [batch_size x feature_size]</span>
<span class="sd">    &gt;&gt;&gt; result = mps_layer(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 10])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">in_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">phys_dim</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a tuple[torch.Tensor] or &#39;</span>
                                <span class="s1">&#39;list[torch.Tensor] type&#39;</span><span class="p">)</span>
            <span class="n">n_features</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be int type&#39;</span><span class="p">)</span>
            
        <span class="c1"># out_position</span>
        <span class="k">if</span> <span class="n">out_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_position</span> <span class="o">=</span> <span class="n">n_features</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out_position</span> <span class="o">&gt;</span> <span class="n">n_features</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;`out_position` should be between 0 and </span><span class="si">{</span><span class="n">n_features</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span> <span class="o">=</span> <span class="n">out_position</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># in_dim</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;If `in_dim` is given as a sequence of int, its &#39;</span>
                        <span class="s1">&#39;length should be equal to `n_features` - 1&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">in_dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                                <span class="s1">&#39;`in_dim` should be int, tuple[int] or &#39;</span>
                                <span class="s1">&#39;list[int] type&#39;</span><span class="p">)</span>
                <span class="n">in_dim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">in_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_dim</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_features</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">in_dim</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;`in_dim` should be int, tuple[int] or list[int] type&#39;</span><span class="p">)</span>

            <span class="c1"># out_dim</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out_dim` should be int type&#39;</span><span class="p">)</span>
            
            <span class="c1"># phys_dim</span>
            <span class="n">phys_dim</span> <span class="o">=</span> <span class="n">in_dim</span><span class="p">[:</span><span class="n">out_position</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">out_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_dim</span><span class="p">[</span><span class="n">out_position</span><span class="p">:]</span>
            
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
                         <span class="n">phys_dim</span><span class="o">=</span><span class="n">phys_dim</span><span class="p">,</span>
                         <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                         <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                         <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                         <span class="n">in_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">out_features</span><span class="o">=</span><span class="p">[</span><span class="n">out_position</span><span class="p">],</span>
                         <span class="n">n_batches</span><span class="o">=</span><span class="n">n_batches</span><span class="p">,</span>
                         <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                         <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mpslayer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[:</span><span class="n">out_position</span><span class="p">]</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[(</span><span class="n">out_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="n">out_position</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns input dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the output dimension, that is, the number of labels in the</span>
<span class="sd">        output node. Same as ``in_dim`` for input nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns position of the output node (label).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the output node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">]</span>
    
<div class="viewcode-block" id="MPSLayer.initialize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPSLayer.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">init_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                   <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes all the nodes of the :class:`MPSLayer`. It can be called when</span>
<span class="sd">        instantiating the model, or to override the existing nodes&#39; tensors.</span>
<span class="sd">        </span>
<span class="sd">        There are different methods to initialize the nodes:</span>
<span class="sd">        </span>
<span class="sd">        * ``{&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;}``: Each node is</span>
<span class="sd">          initialized calling :meth:`~tensorkrowch.AbstractNode.set_tensor` with</span>
<span class="sd">          the given method, ``device`` and ``kwargs``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;randn_eye&quot;``: Nodes are initialized as in this</span>
<span class="sd">          `paper &lt;https://arxiv.org/abs/1605.03795&gt;`_, adding identities at the</span>
<span class="sd">          top of random gaussian tensors. In this case, ``std`` should be</span>
<span class="sd">          specified with a low value, e.g., ``std = 1e-9``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;unit&quot;``: Nodes are initialized as random unitaries, so that the</span>
<span class="sd">          MPS is in canonical form, with the orthogonality center at the</span>
<span class="sd">          rightmost node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensors : list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">            Sequence of tensors to set in each of the MPS nodes. If ``boundary``</span>
<span class="sd">            is ``&quot;obc&quot;``, all tensors should be rank-3, except the first and</span>
<span class="sd">            last ones, which can be rank-2, or rank-1 (if the first and last are</span>
<span class="sd">            the same). If ``boundary`` is ``&quot;pbc&quot;``, all tensors should be</span>
<span class="sd">            rank-3.</span>
<span class="sd">        init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">            Initialization method.</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">        kwargs : float</span>
<span class="sd">            Keyword arguments for the different initialization methods. See</span>
<span class="sd">            :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_left_node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_right_node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span>
            <span class="n">tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_unitaries</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a sequence of `n_features`&#39;</span>
                                 <span class="s1">&#39; elements&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                <span class="n">tensors</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Left node</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">device</span><span class="o">=</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">aux_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                    
                    <span class="c1"># Right node</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                             <span class="n">device</span><span class="o">=</span><span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">aux_tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                
            <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span>
                
        <span class="k">elif</span> <span class="n">init_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;randn_eye&#39;</span><span class="p">:</span>
                <span class="n">init_method</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span>
                <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">add_eye</span><span class="p">:</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                           <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">:</span>
                        <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">eye_tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">eye_tensor</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="n">aux_tensor</span> <span class="o">+=</span> <span class="n">eye_tensor</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aux_tensor</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">eye_tensor</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">==</span> <span class="s1">&#39;obc&#39;</span><span class="p">:</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Left node</span>
                        <span class="n">aux_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Right node</span>
                        <span class="n">aux_tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span></div>

<div class="viewcode-block" id="MPSLayer.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.MPSLayer.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;MPSLayer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`MPSLayer`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied MPSLayer should be</span>
<span class="sd">            set as the tensors in the current MPSLayer (``True``), or cloned</span>
<span class="sd">            (``False``). In the former case, tensors in both MPSLayer&#39;s will be</span>
<span class="sd">            the same, which might be useful if one needs more than one copy</span>
<span class="sd">            of an MPSLayer, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensors.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MPSLayer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">MPSLayer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span>
                           <span class="n">in_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span><span class="p">,</span>
                           <span class="n">out_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span><span class="p">,</span>
                           <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">,</span>
                           <span class="n">out_position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">,</span>
                           <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span>
                           <span class="n">tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">n_batches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">,</span>
                           <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_mps</span></div></div>


<div class="viewcode-block" id="UMPSLayer"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPSLayer">[docs]</a><span class="k">class</span> <span class="nc">UMPSLayer</span><span class="p">(</span><span class="n">MPS</span><span class="p">):</span>  <span class="c1"># MARK: UMPSLayer</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for Uniform (translationally invariant) Matrix Product States with an</span>
<span class="sd">    output node. It is the uniform version of :class:`MPSLayer`, with all input</span>
<span class="sd">    nodes sharing the same tensor, but with a different node for the output node.</span>
<span class="sd">    Thus this class cannot have different input or bond dimensions for each node,</span>
<span class="sd">    and boundary conditions are always periodic (``&quot;pbc&quot;``).</span>
<span class="sd">    </span>
<span class="sd">    |</span>
<span class="sd">    </span>
<span class="sd">    For a more detailed list of inherited properties and methods,</span>
<span class="sd">    check :class:`MPS`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_features : int</span>
<span class="sd">        Number of nodes that will be in ``mats_env``. This also includes the</span>
<span class="sd">        output node, so if one wants to instantiate a ``UMPSLayer`` for a</span>
<span class="sd">        dataset with ``n`` features, it should be ``n_features = n + 1``, to</span>
<span class="sd">        account for the output node.</span>
<span class="sd">    in_dim : int, optional</span>
<span class="sd">        Input dimension. Equivalent to the physical dimension but only for</span>
<span class="sd">        input nodes.</span>
<span class="sd">    out_dim : int, optional</span>
<span class="sd">        Output dimension (labels) for the output node.</span>
<span class="sd">    bond_dim : int, optional</span>
<span class="sd">        Bond dimension.</span>
<span class="sd">    out_position : int, optional</span>
<span class="sd">        Position of the output node (label). Should be between 0 and</span>
<span class="sd">        ``n_features - 1``. If ``None``, the output node will be located at the</span>
<span class="sd">        middle of the MPS.</span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        Instead of providing ``in_dim``, ``out_dim`` and ``bond_dim``, a</span>
<span class="sd">        sequence of 2 tensors can be provided, the first one will be the uniform</span>
<span class="sd">        tensor, and the second one will be the output node&#39;s tensor.</span>
<span class="sd">        ``n_features`` is still needed to specify how many times the uniform</span>
<span class="sd">        tensor should be used to form a finite MPS. In this case, since the</span>
<span class="sd">        output node will have a different tensor, the uniform tensor will be</span>
<span class="sd">        used in the remaining ``n_features - 1`` input nodes. Both tensors</span>
<span class="sd">        should be rank-3, with all their first and last dimensions being equal.</span>
<span class="sd">    n_batches : int</span>
<span class="sd">        Number of batch edges of input ``data`` nodes. Usually ``n_batches = 1``</span>
<span class="sd">        (where the batch edge is used for the data batched) but it could also</span>
<span class="sd">        be ``n_batches = 2`` (one edge for data batched, other edge for image</span>
<span class="sd">        patches in convolutional layers).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mps_layer = tk.models.UMPSLayer(n_features=4,</span>
<span class="sd">    ...                                 in_dim=2,</span>
<span class="sd">    ...                                 out_dim=10,</span>
<span class="sd">    ...                                 bond_dim=5)</span>
<span class="sd">    &gt;&gt;&gt; for i, node in enumerate(mps_layer.mats_env):</span>
<span class="sd">    ...     if i != mps_layer.out_position: </span>
<span class="sd">    ...         assert node.tensor_address() == &#39;virtual_uniform&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 3, 2) # batch_size x (n_features - 1) x feature_size</span>
<span class="sd">    &gt;&gt;&gt; result = mps_layer(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 10])</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">in_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">out_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_batches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">phys_dim</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># n_features</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be int type&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_features</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`n_features` should be at least 1&#39;</span><span class="p">)</span>
            
        <span class="c1"># out_position</span>
        <span class="k">if</span> <span class="n">out_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_position</span> <span class="o">=</span> <span class="n">n_features</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out_position</span> <span class="o">&gt;</span> <span class="n">n_features</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;`out_position` should be between 0 and </span><span class="si">{</span><span class="n">n_features</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span> <span class="o">=</span> <span class="n">out_position</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># in_dim</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">in_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_dim</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_features</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">in_dim</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;`in_dim` should be int, tuple[int] or list[int] type&#39;</span><span class="p">)</span>

            <span class="c1"># out_dim</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out_dim` should be int type&#39;</span><span class="p">)</span>
            
            <span class="c1"># phys_dim</span>
            <span class="n">phys_dim</span> <span class="o">=</span> <span class="n">in_dim</span><span class="p">[:</span><span class="n">out_position</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">out_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_dim</span><span class="p">[</span><span class="n">out_position</span><span class="p">:]</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tensors` should be a tuple[torch.Tensor] or &#39;</span>
                                <span class="s1">&#39;list[torch.Tensor] type&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tensors` should have 2 elements, the first&#39;</span>
                                 <span class="s1">&#39; corresponding to the common input tensor, &#39;</span>
                                 <span class="s1">&#39;and another one for the output node&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;Elements of `tensors` should be torch.Tensor type&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Elements of `tensors` should be a rank-3 tensor&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Elements of `tensors` should have equal first and last&#39;</span>
                        <span class="s1">&#39; dimensions so that the MPS can have periodic boundary&#39;</span>
                        <span class="s1">&#39; conditions&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">n_features</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Only output node is used, uniform memory will</span>
                <span class="c1"># take that tensor too</span>
                <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">out_position</span> <span class="o">+</span> <span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> \
                    <span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">out_position</span><span class="p">)</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
                         <span class="n">phys_dim</span><span class="o">=</span><span class="n">phys_dim</span><span class="p">,</span>
                         <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                         <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span>
                         <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                         <span class="n">in_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">out_features</span><span class="o">=</span><span class="p">[</span><span class="n">out_position</span><span class="p">],</span>
                         <span class="n">n_batches</span><span class="o">=</span><span class="n">n_batches</span><span class="p">,</span>
                         <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                         <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;umpslayer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[:</span><span class="n">out_position</span><span class="p">]</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[(</span><span class="n">out_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="n">out_position</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns input dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the output dimension, that is, the number of labels in the</span>
<span class="sd">        output node. Same as ``in_dim`` for input nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns position of the output node (label).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParamNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the output node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_make_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates all the nodes of the MPS.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_make_nodes</span><span class="p">()</span>
        
        <span class="c1"># Virtual node</span>
        <span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">ParamNode</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_phys_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                   <span class="n">axes_names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">),</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;virtual_uniform&#39;</span><span class="p">,</span>
                                   <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">virtual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">uniform_memory</span>
        
        <span class="n">in_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">]</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">in_nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">set_tensor_from</span><span class="p">(</span><span class="n">uniform_memory</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_make_unitaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes MPS in canonical form.&quot;&quot;&quot;</span>
        <span class="n">tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="p">]:</span>
            <span class="n">node_shape</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">aux_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">numel</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            
            <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">random_unitary</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">),</span> <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">aux_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">)]</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">node_shape</span><span class="p">)</span>
            
            <span class="n">tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensors</span>

<div class="viewcode-block" id="UMPSLayer.initialize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPSLayer.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">init_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                   <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the common tensor of the :class:`UMPSLayer`. It can be called</span>
<span class="sd">        when instantiating the model, or to override the existing nodes&#39; tensors.</span>
<span class="sd">        </span>
<span class="sd">        There are different methods to initialize the nodes:</span>
<span class="sd">        </span>
<span class="sd">        * ``{&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;}``: The tensor is</span>
<span class="sd">          initialized calling :meth:`~tensorkrowch.AbstractNode.set_tensor` with</span>
<span class="sd">          the given method, ``device`` and ``kwargs``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;randn_eye&quot;``: Tensor is initialized as in this</span>
<span class="sd">          `paper &lt;https://arxiv.org/abs/1605.03795&gt;`_, adding identities at the</span>
<span class="sd">          top of a random gaussian tensor. In this case, ``std`` should be</span>
<span class="sd">          specified with a low value, e.g., ``std = 1e-9``.</span>
<span class="sd">        </span>
<span class="sd">        * ``&quot;unit&quot;``: Tensor is initialized as a random unitary, so that the</span>
<span class="sd">          MPS is in canonical form.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensors : list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">            Sequence of a 2 tensors, the first one will be the uniform tensor</span>
<span class="sd">            that will be set in all input nodes, and the second one will be the</span>
<span class="sd">            output node&#39;s tensor. Both tensors should be rank-3, with all their</span>
<span class="sd">            first and last dimensions being equal.</span>
<span class="sd">        init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">            Initialization method.</span>
<span class="sd">        device : torch.device, optional</span>
<span class="sd">            Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">        kwargs : float</span>
<span class="sd">            Keyword arguments for the different initialization methods. See</span>
<span class="sd">            :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;unit&#39;</span><span class="p">:</span>
            <span class="n">tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_unitaries</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">elif</span> <span class="n">init_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="p">]):</span>
                <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">init_method</span> <span class="o">==</span> <span class="s1">&#39;randn_eye&#39;</span><span class="p">:</span>
                    <span class="n">init_method</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span>
                    <span class="n">add_eye</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="n">node</span><span class="o">.</span><span class="n">set_tensor</span><span class="p">(</span><span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">add_eye</span><span class="p">:</span>
                    <span class="n">aux_tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                           <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">aux_tensor</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">eye_tensor</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">eye_tensor</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">eye_tensor</span> <span class="o">=</span> <span class="n">eye_tensor</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="n">aux_tensor</span> <span class="o">+=</span> <span class="n">eye_tensor</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">aux_tensor</span></div>
    
<div class="viewcode-block" id="UMPSLayer.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPSLayer.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;UMPSLayer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`UMPSLayer`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied UMPSLayer should be</span>
<span class="sd">            set as the tensors in the current UMPSLayer (``True``), or cloned</span>
<span class="sd">            (``False``). In the former case, tensors in both UMPSLayer&#39;s will be</span>
<span class="sd">            the same, which might be useful if one needs more than one copy</span>
<span class="sd">            of an UMPSLayer, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensors.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UMPSLayer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">UMPSLayer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span>
                            <span class="n">in_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_dim</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">out_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_dim</span><span class="p">,</span>
                            <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">,</span>
                            <span class="n">out_position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_position</span><span class="p">,</span>
                            <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">n_batches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_batches</span><span class="p">,</span>
                            <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_mps</span></div>
    
<div class="viewcode-block" id="UMPSLayer.parameterize"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.UMPSLayer.parameterize">[docs]</a>    <span class="k">def</span> <span class="nf">parameterize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">set_param</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">override</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TensorNetwork&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes all nodes of the MPS. If there are ``resultant`` nodes</span>
<span class="sd">        in the MPS, it will be first :meth:`~tensorkrowch.TensorNetwork.reset`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        set_param : bool</span>
<span class="sd">            Boolean indicating whether the tensor network has to be parameterized</span>
<span class="sd">            (``True``) or de-parameterized (``False``).</span>
<span class="sd">        override : bool</span>
<span class="sd">            Boolean indicating whether the tensor network should be parameterized</span>
<span class="sd">            in-place (``True``) or copied and then parameterized (``False``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resultant_nodes</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Resultant nodes will be removed before parameterizing the TN&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">override</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">share_tensors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">):</span>
            <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
        
        <span class="c1"># It is important that uniform_memory is parameterized after the rest</span>
        <span class="c1"># of the nodes</span>
        <span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">set_param</span><span class="p">)</span>
        
        <span class="c1"># Tensor addresses have to be reassigned to reference</span>
        <span class="c1"># the uniform memory</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">set_tensor_from</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">uniform_memory</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">net</span></div>
    
    <span class="k">def</span> <span class="nf">canonicalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">oc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">mode</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;svd&#39;</span><span class="p">,</span>
                     <span class="n">rank</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cum_percentage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">renormalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;`canonicalize` not implemented for UMPSLayer&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">canonicalize_univocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;`canonicalize_univocal` not implemented for UMPSLayer&#39;</span><span class="p">)</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#                                 CONV MODELS                                 #</span>
<span class="c1">###############################################################################</span>
<span class="k">class</span> <span class="nc">AbstractConvClass</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>  <span class="c1"># MARK: AbstractConvClass</span>
    
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">_set_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">kernel_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`kernel_size` must be int, list[int] or tuple[int]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`stride` must be int, list[int] or tuple[int]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`padding` must be int, list[int] or tuple[int]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dilation</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">dilation</span> <span class="o">=</span> <span class="p">(</span><span class="n">dilation</span><span class="p">,</span> <span class="n">dilation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dilation</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`dilation` must be int , list[int] or tuple[int]&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span> <span class="o">=</span> <span class="n">in_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stride</span> <span class="o">=</span> <span class="n">stride</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dilation</span> <span class="o">=</span> <span class="n">dilation</span>
        
        <span class="n">unfold</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Unfold</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                           <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                           <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                           <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unfold</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides :meth:`~tensorkrowch.TensorNetwork.forward` to compute a</span>
<span class="sd">        convolution on the input image.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : torch.Tensor</span>
<span class="sd">            Input batch of images with shape</span>
<span class="sd">            </span>
<span class="sd">            .. math::</span>
<span class="sd">            </span>
<span class="sd">                batch\_size \times in\_channels \times height \times width</span>
<span class="sd">        mode : {&quot;flat&quot;, &quot;snake&quot;}</span>
<span class="sd">            Indicates the order in which MPS should take the pixels in the image.</span>
<span class="sd">            When ``&quot;flat&quot;``, the image is flattened putting one row of the image</span>
<span class="sd">            after the other. When ``&quot;snake&quot;``, its row is put in the opposite</span>
<span class="sd">            orientation as the previous row (like a snake running through the</span>
<span class="sd">            image).</span>
<span class="sd">        args :</span>
<span class="sd">            Arguments that might be used in :meth:`~MPS.contract`.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Keyword arguments that might be used in :meth:`~MPS.contract`,</span>
<span class="sd">            like ``inline_input`` or ``inline_mats``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Input image shape: batch_size x in_channels x height x width</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># batch_size x nb_windows x (in_channels * nb_pixels)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">patches</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_channels</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># batch_size x nb_windows x in_channels x nb_pixels</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># batch_size x nb_windows x nb_pixels x in_channels</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;snake&#39;</span><span class="p">:</span>
            <span class="n">new_patches</span> <span class="o">=</span> <span class="n">patches</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">patches</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">patches</span><span class="p">[</span><span class="o">...</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">:]</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_patches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">new_patches</span><span class="p">,</span> <span class="n">aux</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">patches</span> <span class="o">=</span> <span class="n">new_patches</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`mode` can only be &quot;flat&quot; or &quot;snake&quot;&#39;</span><span class="p">)</span>
        
        <span class="n">h_in</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">w_in</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">h_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">h_in</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">w_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">w_in</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># batch_size x nb_windows (x out_channels ...)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">movedim</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># batch_size (x out_channels ...) x nb_windows</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h_out</span><span class="p">,</span> <span class="n">w_out</span><span class="p">)</span>
        <span class="c1"># batch_size (x out_channels ...) x height_out x width_out</span>

        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="ConvMPS"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvMPS">[docs]</a><span class="k">class</span> <span class="nc">ConvMPS</span><span class="p">(</span><span class="n">AbstractConvClass</span><span class="p">,</span> <span class="n">MPS</span><span class="p">):</span>  <span class="c1"># MARK: ConvMPS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolutional version of :class:`MPS`, where the input data is assumed to</span>
<span class="sd">    be a batch of images.</span>
<span class="sd">    </span>
<span class="sd">    Input data as well as initialization parameters are described in `torch.nn.Conv2d</span>
<span class="sd">    &lt;https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_channels : int</span>
<span class="sd">        Input channels. Same as ``phys_dim`` in :class:`MPS`.</span>
<span class="sd">    bond_dim : int, list[int] or tuple[int]</span>
<span class="sd">        Bond dimension(s). If given as a sequence, its length should be equal</span>
<span class="sd">        to :math:`kernel\_size_0 \cdot kernel\_size_1` (if ``boundary = &quot;pbc&quot;``)</span>
<span class="sd">        or :math:`kernel\_size_0 \cdot kernel\_size_1 - 1` (if</span>
<span class="sd">        ``boundary = &quot;obc&quot;``). The i-th bond dimension is always the dimension</span>
<span class="sd">        of the right edge of the i-th node.</span>
<span class="sd">    kernel_size : int, list[int] or tuple[int]</span>
<span class="sd">        Kernel size used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">    padding : int</span>
<span class="sd">        Padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    dilation : int</span>
<span class="sd">        Dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    boundary : {&quot;obc&quot;, &quot;pbc&quot;}</span>
<span class="sd">        String indicating whether periodic or open boundary conditions should</span>
<span class="sd">        be used.</span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        To initialize MPS nodes, a list of MPS tensors can be provided. All</span>
<span class="sd">        tensors should be rank-3 tensors, with shape ``(bond_dim, in_channels,</span>
<span class="sd">        bond_dim)``. If the first and last elements are rank-2 tensors, with</span>
<span class="sd">        shapes ``(in_channels, bond_dim)``, ``(bond_dim, in_channels)``,</span>
<span class="sd">        respectively, the inferred boundary conditions will be &quot;obc&quot;. Also, if</span>
<span class="sd">        ``tensors`` contains a single element, it can be rank-1 (&quot;obc&quot;) or</span>
<span class="sd">        rank-3 (&quot;pbc&quot;).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`~MPS.initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; conv_mps = tk.models.ConvMPS(in_channels=2,</span>
<span class="sd">    ...                              bond_dim=5,</span>
<span class="sd">    ...                              kernel_size=2)</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 2, 2, 2) # batch_size x in_channels x height x width</span>
<span class="sd">    &gt;&gt;&gt; result = conv_mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                 <span class="n">kernel_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
                 <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="n">unfold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                                      <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                      <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                                      <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                      <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>

        <span class="n">MPS</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">phys_dim</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                     <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                     <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                     <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                     <span class="n">n_batches</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                     <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span> <span class="o">=</span> <span class="n">unfold</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``in_channels``. Same as ``phys_dim`` in :class:`MPS`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``kernel_size``. Number of nodes is given by</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stride</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stride</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dilation</span>
    
<div class="viewcode-block" id="ConvMPS.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvMPS.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConvMPS&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`ConvMPS`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied ConvMPS should be</span>
<span class="sd">            set as the tensors in the current ConvMPS (``True``), or cloned</span>
<span class="sd">            (``False``). In the former case, tensors in both ConvMPS&#39;s will be</span>
<span class="sd">            the same, which might be useful if one needs more than one copy</span>
<span class="sd">            of a ConvMPS, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ConvMPS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">ConvMPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span><span class="p">,</span>
                          <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">,</span>
                          <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">,</span>
                          <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stride</span><span class="p">,</span>
                          <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_padding</span><span class="p">,</span>
                          <span class="n">dilation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span>
                          <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span>
                          <span class="n">tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_mps</span></div></div>


<div class="viewcode-block" id="ConvUMPS"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvUMPS">[docs]</a><span class="k">class</span> <span class="nc">ConvUMPS</span><span class="p">(</span><span class="n">AbstractConvClass</span><span class="p">,</span> <span class="n">UMPS</span><span class="p">):</span>  <span class="c1"># MARK: ConvUMPS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolutional version of :class:`UMPS`, where the input data is assumed to</span>
<span class="sd">    be a batch of images.</span>
<span class="sd">    </span>
<span class="sd">    Input data as well as initialization parameters are described in `torch.nn.Conv2d</span>
<span class="sd">    &lt;https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_channels : int</span>
<span class="sd">        Input channels. Same as ``phys_dim`` in :class:`UMPS`.</span>
<span class="sd">    bond_dim : int</span>
<span class="sd">        Bond dimension.</span>
<span class="sd">    kernel_size : int, list[int] or tuple[int]</span>
<span class="sd">        Kernel size used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">    padding : int</span>
<span class="sd">        Padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    dilation : int</span>
<span class="sd">        Dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    tensor: torch.Tensor, optional</span>
<span class="sd">        To initialize MPS nodes, a MPS tensor can be provided. The tensor</span>
<span class="sd">        should be rank-3, with its first and last dimensions being equal.</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`~UMPS.initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; conv_mps = tk.models.ConvUMPS(in_channels=2,</span>
<span class="sd">    ...                               bond_dim=5,</span>
<span class="sd">    ...                               kernel_size=2)</span>
<span class="sd">    &gt;&gt;&gt; for node in conv_mps.mats_env:</span>
<span class="sd">    ...     assert node.tensor_address() == &#39;virtual_uniform&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 2, 2, 2) # batch_size x in_channels x height x width</span>
<span class="sd">    &gt;&gt;&gt; result = conv_mps(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">kernel_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
                 <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">tensor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">unfold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                                      <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                      <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                                      <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                      <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>

        <span class="n">UMPS</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">phys_dim</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                      <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                      <span class="n">tensor</span><span class="o">=</span><span class="n">tensor</span><span class="p">,</span>
                      <span class="n">n_batches</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                      <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                      <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span> <span class="o">=</span> <span class="n">unfold</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``in_channels``. Same as ``phys_dim`` in :class:`MPS`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``kernel_size``. Number of nodes is given by</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stride</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stride</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dilation</span>
    
<div class="viewcode-block" id="ConvUMPS.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvUMPS.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConvUMPS&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`ConvUMPS`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether the common tensor in the copied ConvUMPS</span>
<span class="sd">            should be set as the tensor in the current ConvUMPS (``True``), or</span>
<span class="sd">            cloned (``False``). In the former case, the tensor in both ConvUMPS&#39;s</span>
<span class="sd">            will be the same, which might be useful if one needs more than one</span>
<span class="sd">            copy of a ConvUMPS, but wants to compute all the gradients with respect</span>
<span class="sd">            to the same, unique, tensor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ConvUMPS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">ConvUMPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span><span class="p">,</span>
                           <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">,</span>
                           <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stride</span><span class="p">,</span>
                           <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_padding</span><span class="p">,</span>
                           <span class="n">dilation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span>
                           <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_mps</span></div></div>


<div class="viewcode-block" id="ConvMPSLayer"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvMPSLayer">[docs]</a><span class="k">class</span> <span class="nc">ConvMPSLayer</span><span class="p">(</span><span class="n">AbstractConvClass</span><span class="p">,</span> <span class="n">MPSLayer</span><span class="p">):</span>  <span class="c1"># MARK: ConvMPSLayer</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolutional version of :class:`MPSLayer`, where the input data is assumed to</span>
<span class="sd">    be a batch of images.</span>
<span class="sd">    </span>
<span class="sd">    Input data as well as initialization parameters are described in `torch.nn.Conv2d</span>
<span class="sd">    &lt;https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_channels : int</span>
<span class="sd">        Input channels. Same as ``in_dim`` in :class:`MPSLayer`.</span>
<span class="sd">    out_channels : int</span>
<span class="sd">        Output channels. Same as ``out_dim`` in :class:`MPSLayer`.</span>
<span class="sd">    bond_dim : int, list[int] or tuple[int]</span>
<span class="sd">        Bond dimension(s). If given as a sequence, its length should be equal</span>
<span class="sd">        to :math:`kernel\_size_0 \cdot kernel\_size_1 + 1`</span>
<span class="sd">        (if ``boundary = &quot;pbc&quot;``) or :math:`kernel\_size_0 \cdot kernel\_size_1`</span>
<span class="sd">        (if ``boundary = &quot;obc&quot;``). The i-th bond dimension is always the dimension</span>
<span class="sd">        of the right edge of the i-th node (including output node).</span>
<span class="sd">    kernel_size : int, list[int] or tuple[int]</span>
<span class="sd">        Kernel size used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">    padding : int</span>
<span class="sd">        Padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    dilation : int</span>
<span class="sd">        Dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    out_position : int, optional</span>
<span class="sd">        Position of the output node (label). Should be between 0 and</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1`. If ``None``, the output node</span>
<span class="sd">        will be located at the middle of the MPS.</span>
<span class="sd">    boundary : {&quot;obc&quot;, &quot;pbc&quot;}</span>
<span class="sd">        String indicating whether periodic or open boundary conditions should</span>
<span class="sd">        be used.</span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        To initialize MPS nodes, a list of MPS tensors can be provided. All</span>
<span class="sd">        tensors should be rank-3 tensors, with shape ``(bond_dim, in_channels,</span>
<span class="sd">        bond_dim)``. If the first and last elements are rank-2 tensors, with</span>
<span class="sd">        shapes ``(in_channels, bond_dim)``, ``(bond_dim, in_channels)``,</span>
<span class="sd">        respectively, the inferred boundary conditions will be &quot;obc&quot;. Also, if</span>
<span class="sd">        ``tensors`` contains a single element, it can be rank-1 (&quot;obc&quot;) or</span>
<span class="sd">        rank-3 (&quot;pbc&quot;).</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`~MPSLayer.initialize` for a more detailed</span>
<span class="sd">        explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; conv_mps_layer = tk.models.ConvMPSLayer(in_channels=2,</span>
<span class="sd">    ...                                         out_channels=10,</span>
<span class="sd">    ...                                         bond_dim=5,</span>
<span class="sd">    ...                                         kernel_size=2)</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 2, 2, 2) # batch_size x in_channels x height x width</span>
<span class="sd">    &gt;&gt;&gt; result = conv_mps_layer(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 10, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">out_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                 <span class="n">kernel_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
                 <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">out_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">boundary</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;obc&#39;</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">unfold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                                      <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                      <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                                      <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                      <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>

        <span class="n">MPSLayer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                              <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">in_dim</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                          <span class="n">out_dim</span><span class="o">=</span><span class="n">out_channels</span><span class="p">,</span>
                          <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                          <span class="n">out_position</span><span class="o">=</span><span class="n">out_position</span><span class="p">,</span>
                          <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
                          <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                          <span class="n">n_batches</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                          <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                          <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span> <span class="o">=</span> <span class="n">out_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span> <span class="o">=</span> <span class="n">unfold</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``in_channels``. Same as ``in_dim`` in :class:`MPSLayer`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``out_channels``. Same as ``out_dim`` in :class:`MPSLayer`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``kernel_size``. Number of nodes is given by</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1 + 1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stride</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stride</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dilation</span>
    
<div class="viewcode-block" id="ConvMPSLayer.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvMPSLayer.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConvMPSLayer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`ConvMPSLayer`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied ConvMPSLayer should</span>
<span class="sd">            be set as the tensors in the current ConvMPSLayer (``True``), or</span>
<span class="sd">            cloned (``False``). In the former case, tensors in both ConvMPSLayer&#39;s</span>
<span class="sd">            will be the same, which might be useful if one needs more than one</span>
<span class="sd">            copy of an ConvMPSLayer, but wants to compute all the gradients with</span>
<span class="sd">            respect to the same, unique, tensors.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ConvMPSLayer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">ConvMPSLayer</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span><span class="p">,</span>
                               <span class="n">out_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span><span class="p">,</span>
                               <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">,</span>
                               <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">,</span>
                               <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stride</span><span class="p">,</span>
                               <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_padding</span><span class="p">,</span>
                               <span class="n">dilation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span>
                               <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span>
                               <span class="n">tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_mps</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats_env</span><span class="p">):</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_mps</span></div></div>


<div class="viewcode-block" id="ConvUMPSLayer"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvUMPSLayer">[docs]</a><span class="k">class</span> <span class="nc">ConvUMPSLayer</span><span class="p">(</span><span class="n">AbstractConvClass</span><span class="p">,</span> <span class="n">UMPSLayer</span><span class="p">):</span>  <span class="c1"># MARK: ConvUMPSLayer</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolutional version of :class:`UMPSLayer`, where the input data is assumed to</span>
<span class="sd">    be a batch of images.</span>
<span class="sd">    </span>
<span class="sd">    Input data as well as initialization parameters are described in `torch.nn.Conv2d</span>
<span class="sd">    &lt;https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_channels : int</span>
<span class="sd">        Input channels. Same as ``in_dim`` in :class:`UMPSLayer`.</span>
<span class="sd">    out_channels : int</span>
<span class="sd">        Output channels. Same as ``out_dim`` in :class:`UMPSLayer`.</span>
<span class="sd">    bond_dim : int</span>
<span class="sd">        Bond dimension.</span>
<span class="sd">    kernel_size : int, list[int] or tuple[int]</span>
<span class="sd">        Kernel size used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">    padding : int</span>
<span class="sd">        Padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    dilation : int</span>
<span class="sd">        Dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        If given as an ``int``, the actual kernel size will be</span>
<span class="sd">        ``(kernel_size, kernel_size)``.</span>
<span class="sd">    out_position : int, optional</span>
<span class="sd">        Position of the output node (label). Should be between 0 and</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1`. If ``None``, the output node</span>
<span class="sd">        will be located at the middle of the MPS.</span>
<span class="sd">        </span>
<span class="sd">    tensors: list[torch.Tensor] or tuple[torch.Tensor], optional</span>
<span class="sd">        To initialize MPS nodes, a sequence of 2 tensors can be provided, the</span>
<span class="sd">        first one will be the uniform tensor, and the second one will be the</span>
<span class="sd">        output node&#39;s tensor. Both tensors should be rank-3, with all their</span>
<span class="sd">        first and last dimensions being equal.</span>
<span class="sd">    init_method : {&quot;zeros&quot;, &quot;ones&quot;, &quot;copy&quot;, &quot;rand&quot;, &quot;randn&quot;, &quot;randn_eye&quot;, &quot;unit&quot;}, optional</span>
<span class="sd">        Initialization method. Check :meth:`~UMPSLayer.initialize` for a more</span>
<span class="sd">        detailed explanation of the different initialization methods.</span>
<span class="sd">    device : torch.device, optional</span>
<span class="sd">        Device where to initialize the tensors if ``init_method`` is provided.</span>
<span class="sd">    kwargs : float</span>
<span class="sd">        Keyword arguments for the different initialization methods. See</span>
<span class="sd">        :meth:`~tensorkrowch.AbstractNode.make_tensor`.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; conv_mps_layer = tk.models.ConvUMPSLayer(in_channels=2,</span>
<span class="sd">    ...                                          out_channels=10,</span>
<span class="sd">    ...                                          bond_dim=5,</span>
<span class="sd">    ...                                          kernel_size=2)</span>
<span class="sd">    &gt;&gt;&gt; for i, node in enumerate(conv_mps_layer.mats_env):</span>
<span class="sd">    ...     if i != conv_mps_layer.out_position:</span>
<span class="sd">    ...         assert node.tensor_address() == &#39;virtual_uniform&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; data = torch.ones(20, 2, 2, 2) # batch_size x in_channels x height x width</span>
<span class="sd">    &gt;&gt;&gt; result = conv_mps_layer(data)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    torch.Size([20, 10, 1, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">out_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">bond_dim</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                 <span class="n">kernel_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">],</span>
                 <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">dilation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">out_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">tensors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">init_method</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">unfold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_attributes</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                                      <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                      <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                                      <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                      <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>

        <span class="n">UMPSLayer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">n_features</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                               <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">in_dim</span><span class="o">=</span><span class="n">in_channels</span><span class="p">,</span>
                           <span class="n">out_dim</span><span class="o">=</span><span class="n">out_channels</span><span class="p">,</span>
                           <span class="n">bond_dim</span><span class="o">=</span><span class="n">bond_dim</span><span class="p">,</span>
                           <span class="n">out_position</span><span class="o">=</span><span class="n">out_position</span><span class="p">,</span>
                           <span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
                           <span class="n">n_batches</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">init_method</span><span class="o">=</span><span class="n">init_method</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span> <span class="o">=</span> <span class="n">out_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span> <span class="o">=</span> <span class="n">unfold</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``in_channels``. Same as ``in_dim`` in :class:`UMPSLayer`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``out_channels``. Same as ``out_dim`` in :class:`UMPSLayer`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``kernel_size``. Number of nodes is given by</span>
<span class="sd">        :math:`kernel\_size_0 \cdot kernel\_size_1 + 1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stride</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns stride used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stride</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns padding used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dilation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dilation used in `torch.nn.Unfold</span>
<span class="sd">        &lt;https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dilation</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``out_channels``. Same as ``phys_dim`` in :class:`MPS`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span>

<div class="viewcode-block" id="ConvUMPSLayer.copy"><a class="viewcode-back" href="../../../models.html#tensorkrowch.models.ConvUMPSLayer.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ConvUMPSLayer&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the :class:`ConvUMPSLayer`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        share_tensor : bool, optional</span>
<span class="sd">            Boolean indicating whether tensors in the copied ConvUMPSLayer should</span>
<span class="sd">            be set as the tensors in the current ConvUMPSLayer (``True``), or</span>
<span class="sd">            cloned (``False``). In the former case, tensors in both ConvUMPSLayer&#39;s</span>
<span class="sd">            will be the same, which might be useful if one needs more than one</span>
<span class="sd">            copy of an ConvUMPSLayer, but wants to compute all the gradients with</span>
<span class="sd">            respect to the same, unique, tensors.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ConvUMPSLayer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mps</span> <span class="o">=</span> <span class="n">ConvUMPSLayer</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_in_channels</span><span class="p">,</span>
                                <span class="n">out_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_out_channels</span><span class="p">,</span>
                                <span class="n">bond_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bond_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_size</span><span class="p">,</span>
                                <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stride</span><span class="p">,</span>
                                <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_padding</span><span class="p">,</span>
                                <span class="n">dilation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dilation</span><span class="p">,</span>
                                <span class="n">tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">init_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_mps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_copy&#39;</span>
        <span class="k">if</span> <span class="n">share_tensors</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniform_memory</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">new_mps</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_node</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">new_mps</span></div></div>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By José Ramón Pareja Monturiol<br/>
  
      &copy; Copyright 2023, José Ramón Pareja Monturiol.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>