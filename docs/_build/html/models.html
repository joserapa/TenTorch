
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Models &#8212; TensorKrowch 1.1.5 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="_static/tensorkrowch_favicon_light.svg"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Initializers" href="initializers.html" />
    <link rel="prev" title="Operations" href="operations.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/tensorkrowch_logo_light.svg" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="tutorials.html">
   Tutorials
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/0_first_steps.html">
     First Steps with TensorKrowch
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/1_creating_tensor_network.html">
     Creating a Tensor Network in TensorKrowch
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/2_contracting_tensor_network.html">
     Contracting and Differentiating the Tensor Network
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/3_memory_management.html">
     How to save Memory and Time with TensorKrowch (ADVANCED)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/4_types_of_nodes.html">
     The different Types of Nodes (ADVANCED)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/5_subclass_tensor_network.html">
     How to subclass TensorNetwork to build Custom Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorials/6_mix_with_pytorch.html">
     Creating a Hybrid Neural-Tensor Network Model
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="examples.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/training_mps.html">
     Training MPS in different ways
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/hybrid_tnn_model.html">
     Hybrid Tensorial Neural Network model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/tensorizing_nn.html">
     Tensorizing Neural Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/mps_dmrg.html">
     DMRG-like training of MPS
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/mps_dmrg_hybrid.html">
     Hybrid DMRG-like training of MPS
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="api.html">
   API Reference
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="components.html">
     Components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="operations.html">
     Operations
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="initializers.html">
     Initializers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="embeddings.html">
     Embeddings
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="decompositions.html">
     Decompositions
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/joserapa98/tensorkrowch"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/models.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mps">
   MPS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     MPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umps">
     UMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mpslayer">
     MPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umpslayer">
     UMPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convmps">
     ConvMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convumps">
     ConvUMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convmpslayer">
     ConvMPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convumpslayer">
     ConvUMPSLayer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mpsdata">
   MPSData
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id35">
     MPSData
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mpo">
   MPO
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id36">
     MPO
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umpo">
     UMPO
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tree">
   Tree
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id37">
     Tree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#utree">
     UTree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convtree">
     ConvTree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convutree">
     ConvUTree
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#peps">
   PEPS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id54">
     PEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#upeps">
     UPEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convpeps">
     ConvPEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convupeps">
     ConvUPEPS
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Models</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mps">
   MPS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     MPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umps">
     UMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mpslayer">
     MPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umpslayer">
     UMPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convmps">
     ConvMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convumps">
     ConvUMPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convmpslayer">
     ConvMPSLayer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convumpslayer">
     ConvUMPSLayer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mpsdata">
   MPSData
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id35">
     MPSData
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mpo">
   MPO
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id36">
     MPO
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#umpo">
     UMPO
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tree">
   Tree
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id37">
     Tree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#utree">
     UTree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convtree">
     ConvTree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convutree">
     ConvUTree
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#peps">
   PEPS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id54">
     PEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#upeps">
     UPEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convpeps">
     ConvPEPS
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convupeps">
     ConvUPEPS
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="models">
<h1>Models<a class="headerlink" href="#models" title="Permalink to this headline">#</a></h1>
<section id="mps">
<h2>MPS<a class="headerlink" href="#mps" title="Permalink to this headline">#</a></h2>
<section id="id1">
<h3>MPS<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">MPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phys_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Matrix Product States. This is the base class from which
<a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPS</span></code></a>, <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a> and <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a> inherit.</p>
<p>Matrix Product States are formed by:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mats_env</span></code>: Environment of <cite>matrix</cite> nodes with axes
<code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;input&quot;,</span> <span class="pre">&quot;right&quot;)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_node</span></code>, <code class="docutils literal notranslate"><span class="pre">right_node</span></code>: <cite>Vector</cite> nodes with axes <code class="docutils literal notranslate"><span class="pre">(&quot;right&quot;,)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,)</span></code>, respectively. These are used to close the boundary
in the case <code class="docutils literal notranslate"><span class="pre">boudary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>. Otherwise, both are <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>The base <code class="docutils literal notranslate"><span class="pre">MPS</span></code> class enables setting various nodes as either input or
output nodes. This feature proves useful when computing marginal or
conditional distributions. The assignment of roles can be altered
dynamically, allowing input nodes to transition to output nodes, and vice
versa.</p>
<p>Input nodes will be connected to data nodes at their <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges, and
contracted against them when calling <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>. Output nodes, on the
other hand, will remain disconnected. If <code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code> in
<a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>, the open indices of the output nodes can be marginalized
so that the output is a single scalar (or a vector with only batch
dimensions). If <code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">False</span></code> the result will be a tensor
with as many dimensions as output nodes where in the MPS, plus the
corresponding batch dimensions.</p>
<p>If all input nodes have the same physical dimensions, the input data tensor
can be passed as a single tensor. Otherwise, it would have to be passed as
a list of tensors with different sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>. That is, number of nodes
without taking into account <code class="docutils literal notranslate"><span class="pre">left_node</span></code> and <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p></li>
<li><p><strong>phys_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Physical dimension(s). If given as a sequence, its length should be
equal to <code class="docutils literal notranslate"><span class="pre">n_features</span></code>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code> (if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>) or <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code> (if
<code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node.</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">n_features</span></code>, <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code> and
<code class="docutils literal notranslate"><span class="pre">boundary</span></code>, a list of MPS tensors can be provided. In such case, all
mentioned attributes will be inferred from the given tensors. All
tensors should be rank-3 tensors, with shape <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">phys_dim,</span>
<span class="pre">bond_dim)</span></code>. If the first and last elements are rank-2 tensors, with
shapes <code class="docutils literal notranslate"><span class="pre">(phys_dim,</span> <span class="pre">bond_dim)</span></code>, <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">phys_dim)</span></code>, respectively,
the inferred boundary conditions will be “obc”. Also, if <code class="docutils literal notranslate"><span class="pre">tensors</span></code>
contains a single element, it can be rank-1 (“obc”) or rank-3 (“pbc”).</p></li>
<li><p><strong>in_features</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – List of indices indicating the positions of the MPS nodes that will be
considered as input nodes. These nodes will have a neighbouring data
node connected to its <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edge when the <a class="reference internal" href="#tensorkrowch.models.MPS.set_data_nodes" title="tensorkrowch.models.MPS.set_data_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_data_nodes()</span></code></a>
method is called. <code class="docutils literal notranslate"><span class="pre">in_features</span></code> is the complementary set of
<code class="docutils literal notranslate"><span class="pre">out_features</span></code>, so it is only required to specify one of them.</p></li>
<li><p><strong>out_features</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – List of indices indicating the positions of the MPS nodes that will be
considered as output nodes. These nodes will be left with their <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edges open when contrating the network. If <code class="docutils literal notranslate"><span class="pre">marginalize_output</span></code> is
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>, the network will be connected to
itself at these nodes, and contracted. <code class="docutils literal notranslate"><span class="pre">out_features</span></code> is the
complementary set of <code class="docutils literal notranslate"><span class="pre">in_features</span></code>, so it is only required to specify
one of them.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPS.initialize" title="tensorkrowch.models.MPS.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">MPS</span></code> with the same physical dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">phys_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MPS</span></code> with different physical dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">phys_dim</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span> <span class="c1"># n_features * [batch_size x feature_size]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MPS</span></code> can also be initialized from a list of tensors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">in_features</span></code>/<code class="docutils literal notranslate"><span class="pre">out_features</span></code> are specified, data will only be
connected to the input nodes, leaving output nodes open:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">tensors</span><span class="o">=</span><span class="n">tensors</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">out_features</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 2, 2, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">marginalize_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 20])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.n_features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_features</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.n_features" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.phys_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">phys_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.phys_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns physical dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.boundary" title="Permalink to this definition">#</a></dt>
<dd><p>Returns boundary condition (“obc” or “pbc”).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. To change this
attribute, first call <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.unset_data_nodes" title="tensorkrowch.TensorNetwork.unset_data_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unset_data_nodes()</span></code></a>
if there are already data nodes in the network.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.in_features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_features</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.in_features" title="Permalink to this definition">#</a></dt>
<dd><p>Returns list of positions of the input nodes. To change this
attribute, first call <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.unset_data_nodes" title="tensorkrowch.TensorNetwork.unset_data_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unset_data_nodes()</span></code></a>
if there are already data nodes in the network. When changing it,
<a class="reference internal" href="#tensorkrowch.models.MPS.out_features" title="tensorkrowch.models.MPS.out_features"><code class="xref py py-attr docutils literal notranslate"><span class="pre">out_features</span></code></a> will change accordingly to be the complementary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.out_features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_features</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.out_features" title="Permalink to this definition">#</a></dt>
<dd><p>Returns list of positions of the output nodes. To change this
attribute, first call <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.unset_data_nodes" title="tensorkrowch.TensorNetwork.unset_data_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unset_data_nodes()</span></code></a>
if there are already data nodes in the network. When changing it,
<a class="reference internal" href="#tensorkrowch.models.MPS.in_features" title="tensorkrowch.models.MPS.in_features"><code class="xref py py-attr docutils literal notranslate"><span class="pre">in_features</span></code></a> will change accordingly to be the complementary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.in_regions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_regions</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.in_regions" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a list of lists of consecutive input positions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.out_regions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_regions</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.out_regions" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a list of lists of consecutive output positions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.left_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">left_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.left_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">left_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.right_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">right_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.right_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.mats_env">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mats_env</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.mats_env" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of nodes in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.in_env">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_env</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.in_env" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of input nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.out_env">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_env</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.out_env" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of output nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.tensors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tensors</span></span><a class="headerlink" href="#tensorkrowch.models.MPS.tensors" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of MPS tensors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes of the <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>. It can be called when
instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: Each node is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;randn_eye&quot;</span></code>: Nodes are initialized as in this
<a class="reference external" href="https://arxiv.org/abs/1605.03795">paper</a>, adding identities at the
top of random gaussian tensors. In this case, <code class="docutils literal notranslate"><span class="pre">std</span></code> should be
specified with a low value, e.g., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">1e-9</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;unit&quot;</span></code>: Nodes are initialized as stacks of random unitaries. This,
combined (at least) with an embedding of the inputs as elements of
the computational basis (<a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.discretize" title="tensorkrowch.embeddings.discretize"><code class="xref py py-func docutils literal notranslate"><span class="pre">discretize()</span></code></a>
combined with <a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.basis" title="tensorkrowch.embeddings.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;canonical&quot;`</span></code>: MPS is initialized in canonical form with a squared
norm <cite>close</cite> to the product of all the physical dimensions (if bond
dimensions are bigger than the powers of the physical dimensions,
the norm could vary). Th orthogonality center is at the rightmost
node.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of tensors to set in each of the MPS nodes. If <code class="docutils literal notranslate"><span class="pre">boundary</span></code>
is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>, all tensors should be rank-3, except the first and
last ones, which can be rank-2, or rank-1 (if the first and last are
the same). If <code class="docutils literal notranslate"><span class="pre">boundary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>, all tensors should be
rank-3.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes and connects each of them to the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edge of each input node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied MPS should be
set as the tensors in the current MPS (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or cloned
(<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both MPS’s will be
the same, which might be useful if one needs more than one copy
of an MPS, but wants to compute all the gradients with respect
to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS">MPS</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.parameterize">
<span class="sig-name descname"><span class="pre">parameterize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.parameterize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.parameterize" title="Permalink to this definition">#</a></dt>
<dd><p>Parameterizes all nodes of the MPS. If there are <code class="docutils literal notranslate"><span class="pre">resultant</span></code> nodes
in the MPS, it will be first <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_param</strong> (<em>bool</em>) – Boolean indicating whether the tensor network has to be parameterized
(<code class="docutils literal notranslate"><span class="pre">True</span></code>) or de-parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><strong>override</strong> (<em>bool</em>) – Boolean indicating whether the tensor network should be parameterized
in-place (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or copied and then parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.update_bond_dim">
<span class="sig-name descname"><span class="pre">update_bond_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.update_bond_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.update_bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the <a class="reference internal" href="#tensorkrowch.models.MPS.bond_dim" title="tensorkrowch.models.MPS.bond_dim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_dim</span></code></a> attribute of the <code class="docutils literal notranslate"><span class="pre">MPS</span></code>, in case it is
outdated.</p>
<p>If bond dimensions are changed, usually due to decompositions like
<a class="reference internal" href="operations.html#tensorkrowch.svd" title="tensorkrowch.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">update_bond_dim</span></code> should be
called. This might modify some elements of the model, so it is
recommended to do this before saving the <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> of the model.
Besides, if one wants to continue training, the <code class="docutils literal notranslate"><span class="pre">parameters</span></code> of the
model that are passed to the optimizer should be updated also.
Otherwise, the optimizer could be tracking outdated parameters that are
not members of the model any more.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inline_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline_mats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marginalize_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mpo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole MPS.</p>
<p>If the MPS has input nodes, these are contracted against input <code class="docutils literal notranslate"><span class="pre">data</span></code>
nodes.</p>
<p>If the MPS has output nodes, these can be left with their <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edges open, or can be marginalized, contracting the remaining output
nodes with themselves, if the argument <code class="docutils literal notranslate"><span class="pre">&quot;marginalize_output&quot;</span></code> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>In the latter case, one can add additional nodes in between the MPS-MPS
contraction:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">embedding_matrices</span></code>: A list of matrices with appropiate physical
dimensions can be passed, one for each output node. These matrices
will connect the two <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges of the corresponding nodes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mpo</span></code>: If an <a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a> is passed, when calling
<code class="docutils literal notranslate"><span class="pre">mps(marginalize_output=True,</span> <span class="pre">mpo=mpo)</span></code>, this will perform the
MPS-MPO-MPS contraction at the output nodes of the MPS. Therefore,
the MPO should have as many nodes as output nodes are in the MPS.</p>
<p>After contraction, the MPS will still be connected to the MPO nodes
until these are manually disconnected.</p>
<p>The provided MPO can also be already connected to the MPS before
contraction. In this case, it is assumed that the output nodes of the
MPS are connected to the <code class="docutils literal notranslate"><span class="pre">&quot;output&quot;</span></code> edges of the MPO nodes, and
that the MPO nodes have been moved to the MPS, so that all nodes
belong to the MPS network. In this case, each MPO node will connect
the two <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges of the corresponding MPS nodes.</p>
<p>If the MPO nodes are not trainable, they can be de-parameterized
by doing <code class="docutils literal notranslate"><span class="pre">mpo</span> <span class="pre">=</span> <span class="pre">mpo.parameterize(set_param=False,</span> <span class="pre">override=True)</span></code>.
This should be done before the contraction, or before connecting
the MPO nodes to the MPS, since the de-parameterized nodes are not
the same nodes as the original <code class="docutils literal notranslate"><span class="pre">ParamNodes</span></code> of the MPO.</p>
</li>
</ul>
<p>When <code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code>, the contracted input nodes are
duplicated using different batch dimensions. That is, if the MPS
is contracted with input data with <code class="docutils literal notranslate"><span class="pre">batch_size</span> <span class="pre">=</span> <span class="pre">100</span></code>, and some
other (output) nodes are marginalized, the result will be a tensor
with shape <code class="docutils literal notranslate"><span class="pre">(100,</span> <span class="pre">100)</span></code> rather than just <code class="docutils literal notranslate"><span class="pre">(100,)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inline_input</strong> (<em>bool</em>) – Boolean indicating whether input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes should be contracted
with the <code class="docutils literal notranslate"><span class="pre">MPS</span></code> input nodes inline (one contraction at a time) or
in a single stacked contraction.</p></li>
<li><p><strong>inline_mats</strong> (<em>bool</em>) – Boolean indicating whether the sequence of matrices (resultant
after contracting the input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes) should be contracted
inline or as a sequence of pairwise stacked contrations.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after contraction.
If not, it may happen that the norm explodes or vanishes, as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale. The renormalization only occurs when multiplying
sequences of matrices, once the <cite>input</cite> contractions have been
already performed, including contracting against embedding matrices
or MPOs when <code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p></li>
<li><p><strong>marginalize_output</strong> (<em>bool</em>) – Boolean indicating whether output nodes should be marginalized. If
<code class="docutils literal notranslate"><span class="pre">True</span></code>, after contracting all the input nodes with their
neighbouring data nodes, this resultant network is contracted with
itself connecting output nodes to itselves at <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, output nodes are left with their <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges
disconnected.</p></li>
<li><p><strong>embedding_matrices</strong> (<em>torch.Tensor</em><em>, </em><em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code>, a matrix can be introduced
between each output node and its copy, connecting the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edges. This can be useful when data vectors are not represented
as qubits in the computational basis, but are transformed via
some <a class="reference internal" href="embeddings.html#embeddings"><span class="std std-ref">Embeddings</span></a> function.</p></li>
<li><p><strong>mpo</strong> (<a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><em>MPO</em></a><em>, </em><em>optional</em>) – MPO that is to be contracted with the MPS at the output nodes, if
<code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code>. In this case, the <code class="docutils literal notranslate"><span class="pre">&quot;output&quot;</span></code> edges
of the MPO nodes will be connected to the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edges of the
MPS output nodes. If there are no input nodes, the MPS-MPO-MPS
is performed by calling <code class="docutils literal notranslate"><span class="pre">mps(marginalize_output=True,</span> <span class="pre">mpo=mpo)</span></code>,
without passing extra data tensors.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the norm of the MPS.</p>
<p>This method internally removes all data nodes in the MPS, if any, and
contracts the nodes with themselves. Therefore, this may alter the
usual behaviour of <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a> if the MPS is not
<a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> afterwards. Also, if the MPS
was contracted before with other arguments, it should be <code class="docutils literal notranslate"><span class="pre">reset</span></code>
before calling <code class="docutils literal notranslate"><span class="pre">norm</span></code> to avoid undesired behaviour.</p>
<p>Since the norm is computed by contracting the MPS, it means one can
take gradients of it with respect to the MPS tensors, if it is needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>log_scale</strong> (<em>bool</em>) – Boolean indicating whether the resulting norm should be given in
logarithmoc scale. Useful for cases where the norm explodes or
vanishes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.reduced_density">
<span class="sig-name descname"><span class="pre">reduced_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace_sites</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.reduced_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.reduced_density" title="Permalink to this definition">#</a></dt>
<dd><p>Returns de partial density matrix, tracing out the sites specified
by <code class="docutils literal notranslate"><span class="pre">trace_sites</span></code>: <span class="math notranslate nohighlight">\(\rho_A\)</span>.</p>
<p>This method internally sets <code class="docutils literal notranslate"><span class="pre">out_features</span> <span class="pre">=</span> <span class="pre">trace_sites</span></code>, and calls
the <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.forward" title="tensorkrowch.TensorNetwork.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code></a> method with
<code class="docutils literal notranslate"><span class="pre">marginalize_output</span> <span class="pre">=</span> <span class="pre">True</span></code>. Therefore, it may alter the behaviour
of the MPS if it is not <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>
afterwards. Also, if the MPS was contracted before with other arguments,
it should be <code class="docutils literal notranslate"><span class="pre">reset</span></code> before calling <code class="docutils literal notranslate"><span class="pre">reduced_density</span></code> to avoid
undesired behaviour.</p>
<p>Since the density matrix is computed by contracting the MPS, it means
one can take gradients of it with respect to the MPS tensors, if it
is needed.</p>
<p>This method may also alter the attribute <a class="reference internal" href="#tensorkrowch.models.MPS.n_batches" title="tensorkrowch.models.MPS.n_batches"><code class="xref py py-attr docutils literal notranslate"><span class="pre">n_batches</span></code></a> of the
<a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trace_sites</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Sequence of nodes’ indices in the MPS. These indices specify the
nodes that should be traced to compute the density matrix. If
it is empty <code class="docutils literal notranslate"><span class="pre">[]</span></code>, the total density matrix will be returned,
though this may be costly if <a class="reference internal" href="#tensorkrowch.models.MPS.n_features" title="tensorkrowch.models.MPS.n_features"><code class="xref py py-attr docutils literal notranslate"><span class="pre">n_features</span></code></a> is big.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after contraction.
If not, it may happen that the norm explodes or vanishes, as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale. The renormalization only occurs when multiplying
sequences of matrices, once the <cite>input</cite> contractions have been
already performed.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">phys_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">density</span> <span class="o">=</span> <span class="n">mps</span><span class="o">.</span><span class="n">reduced_density</span><span class="p">(</span><span class="n">trace_sites</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">density</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, 5, 3, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.entropy">
<span class="sig-name descname"><span class="pre">entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">middle_site</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.entropy" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the reduced von Neumann Entropy between subsystems <span class="math notranslate nohighlight">\(A\)</span>
and <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(S(\rho_A)\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> goes from site
0 to <code class="docutils literal notranslate"><span class="pre">middle_site</span></code>, and <span class="math notranslate nohighlight">\(B\)</span> goes from <code class="docutils literal notranslate"><span class="pre">middle_site</span> <span class="pre">+</span> <span class="pre">1</span></code> to
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>To compute the reduced entropy, the MPS is put into canonical form
with orthogonality center at <code class="docutils literal notranslate"><span class="pre">middle_site</span></code>. Bond dimensions are not
changed if possible. Only when the bond dimension is bigger than the
physical dimension multiplied by the other bond dimension of the node,
it will be cropped to that size.</p>
<p>If the MPS is not normalized, it may happen that the computation of the
reduced entropy fails due to errors in the Singular Value
Decompositions. To avoid this, it is recommended to set
<code class="docutils literal notranslate"><span class="pre">renormalize</span> <span class="pre">=</span> <span class="pre">True</span></code>. In this case, the norm of each node after the
SVD is extracted in logarithmic form, and accumulated. As a result,
the function will return the tuple <code class="docutils literal notranslate"><span class="pre">(entropy,</span> <span class="pre">log_norm)</span></code>, which is a
sort of <cite>scaled</cite> reduced entropy. This is, indeed, the reduced entropy
of a distribution, since the schmidt values are normalized to sum up
to 1.</p>
<p>The actual reduced entropy, without rescaling, could be obtained as:</p>
<div class="math notranslate nohighlight">
\[\exp(\texttt{log_norm})^2 \cdot S(\rho_A) -
\exp(\texttt{log_norm})^2 \cdot 2 \cdot \texttt{log_norm}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>middle_site</strong> (<em>int</em>) – Position that separates regios <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. It should
be between 0 and <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">2</span></code>.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after SVD/QR
decompositions. If not, it may happen that the norm explodes as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale after SVD/QR decompositions are computed. Finally,
the normalization factor is evenly distributed among all nodes of
the MPS.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float or tuple[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'svd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cum_percentage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.canonicalize" title="Permalink to this definition">#</a></dt>
<dd><p>Turns MPS into canonical form via local SVD/QR decompositions.</p>
<p>To specify the new bond dimensions, the arguments <code class="docutils literal notranslate"><span class="pre">rank</span></code>,
<code class="docutils literal notranslate"><span class="pre">cum_percentage</span></code> or <code class="docutils literal notranslate"><span class="pre">cutoff</span></code> can be specified. These will be used
equally for all SVD computations.</p>
<p>If none of them are specified, the bond dimensions won’t be modified
if possible. Only when the bond dimension is bigger than the physical
dimension multiplied by the other bond dimension of the node, it will
be cropped to that size.</p>
<p>If rank is not specified, the current bond dimensions will be used as
the rank. That is, the current bond dimensions will be the upper bound
for the possibly new bond dimensions given by the arguments
<code class="docutils literal notranslate"><span class="pre">cum_percentage</span></code> and/or <code class="docutils literal notranslate"><span class="pre">cutoff</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oc</strong> (<em>int</em>) – Position of the orthogonality center. It should be between 0 and
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>mode</strong> (<em>{&quot;svd&quot;</em><em>, </em><em>&quot;svdr&quot;</em><em>, </em><em>&quot;qr&quot;}</em>) – Indicates which decomposition should be used to split a node after
contracting it. See more at <a class="reference internal" href="operations.html#tensorkrowch.svd_" title="tensorkrowch.svd_"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd_()</span></code></a>,
<a class="reference internal" href="operations.html#tensorkrowch.svdr_" title="tensorkrowch.svdr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">svdr_()</span></code></a>, <a class="reference internal" href="operations.html#tensorkrowch.qr_" title="tensorkrowch.qr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code></a>.
If mode is “qr”, operation <a class="reference internal" href="operations.html#tensorkrowch.qr_" title="tensorkrowch.qr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code></a> will be
performed on nodes at the left of the output node, whilst operation
<a class="reference internal" href="operations.html#tensorkrowch.rq_" title="tensorkrowch.rq_"><code class="xref py py-func docutils literal notranslate"><span class="pre">rq_()</span></code></a> will be used for nodes at the right.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of singular values to keep.</p></li>
<li><p><strong>cum_percentage</strong> (<em>float</em><em>, </em><em>optional</em>) – <p>Proportion that should be satisfied between the sum of all singular
values kept and the total sum of all singular values.</p>
<div class="math notranslate nohighlight">
\[\frac{\sum_{i \in \{kept\}}{s_i}}{\sum_{i \in \{all\}}{s_i}} \ge
cum\_percentage\]</div>
</p></li>
<li><p><strong>cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Quantity that lower bounds singular values in order to be kept.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after SVD/QR
decompositions. If not, it may happen that the norm explodes as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale after SVD/QR decompositions are computed. Finally,
the normalization factor is evenly distributed among all nodes of
the MPS.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">phys_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span><span class="o">.</span><span class="n">bond_dim</span>
<span class="go">[3, 3, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPS.canonicalize_univocal">
<span class="sig-name descname"><span class="pre">canonicalize_univocal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPS.canonicalize_univocal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPS.canonicalize_univocal" title="Permalink to this definition">#</a></dt>
<dd><p>Turns MPS into the univocal canonical form defined <a class="reference external" href="https://arxiv.org/abs/2202.12319">here</a>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="umps">
<h3>UMPS<a class="headerlink" href="#umps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">UMPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phys_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform (translationally invariant) Matrix Product States. It is
the uniform version of <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>, that is, all nodes share the same
tensor. Thus this class cannot have different physical or bond dimensions
for each node, and boundary conditions are always periodic (<code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For a more detailed list of inherited properties and methods,
check <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>.</p></li>
<li><p><strong>phys_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Physical dimension.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Bond dimension.</p></li>
<li><p><strong>tensor</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>, a single tensor
can be provided. <code class="docutils literal notranslate"><span class="pre">n_features</span></code> is still needed to specify how many
times the tensor should be used to form a finite MPS. The tensor
should be rank-3, with its first and last dimensions being equal.</p></li>
<li><p><strong>in_features</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – List of indices indicating the positions of the MPS nodes that will be
considered as input nodes. These nodes will have a neighbouring data
node connected to its <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edge when the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_data_nodes()</span></code>
method is called. <code class="docutils literal notranslate"><span class="pre">in_features</span></code> is the complementary set of
<code class="docutils literal notranslate"><span class="pre">out_features</span></code>, so it is only required to specify one of them.</p></li>
<li><p><strong>out_features</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – List of indices indicating the positions of the MPS nodes that will be
considered as output nodes. These nodes will be left with their <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edges open when contrating the network. If <code class="docutils literal notranslate"><span class="pre">marginalize_output</span></code> is
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in <code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code>, the network will be connected to
itself at these nodes, and contracted. <code class="docutils literal notranslate"><span class="pre">out_features</span></code> is the
complementary set of <code class="docutils literal notranslate"><span class="pre">in_features</span></code>, so it is only required to specify
one of them.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.UMPS.initialize" title="tensorkrowch.models.UMPS.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">UMPS</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">phys_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">mps</span><span class="o">.</span><span class="n">mats_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPS.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPS.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPS.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes the common tensor of the <a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPS</span></code></a>. It can be called
when instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: The tensor is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;randn_eye&quot;</span></code>: Tensor is initialized as in this
<a class="reference external" href="https://arxiv.org/abs/1605.03795">paper</a>, adding identities at the
top of a random gaussian tensor. In this case, <code class="docutils literal notranslate"><span class="pre">std</span></code> should be
specified with a low value, e.g., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">1e-9</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;unit&quot;</span></code>: Tensor is initialized as a stack of random unitaries. This,
combined (at least) with an embedding of the inputs as elements of
the computational basis (<a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.discretize" title="tensorkrowch.embeddings.discretize"><code class="xref py py-func docutils literal notranslate"><span class="pre">discretize()</span></code></a>
combined with <a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.basis" title="tensorkrowch.embeddings.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;canonical&quot;`</span></code>: MPS is initialized in canonical form with a squared
norm <cite>close</cite> to the product of all the physical dimensions (if bond
dimensions are bigger than the powers of the physical dimensions,
the norm could vary).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of a single tensor to set in each of the MPS nodes. The
tensor should be rank-3, with its first and last dimensions being
equal.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPS.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPS.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPS.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether the common tensor in the copied UMPS
should be set as the tensor in the current UMPS (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or
cloned (<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, the tensor in both UMPS’s
will be the same, which might be useful if one needs more than one
copy of a UMPS, but wants to compute all the gradients with respect
to the same, unique, tensor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS">UMPS</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPS.parameterize">
<span class="sig-name descname"><span class="pre">parameterize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPS.parameterize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPS.parameterize" title="Permalink to this definition">#</a></dt>
<dd><p>Parameterizes all nodes of the MPS. If there are <code class="docutils literal notranslate"><span class="pre">resultant</span></code> nodes
in the MPS, it will be first <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_param</strong> (<em>bool</em>) – Boolean indicating whether the tensor network has to be parameterized
(<code class="docutils literal notranslate"><span class="pre">True</span></code>) or de-parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><strong>override</strong> (<em>bool</em>) – Boolean indicating whether the tensor network should be parameterized
in-place (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or copied and then parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mpslayer">
<h3>MPSLayer<a class="headerlink" href="#mpslayer" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">MPSLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPSLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSLayer" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Matrix Product States with a single output node. That is, this
MPS has <span class="math notranslate nohighlight">\(n\)</span> nodes, being <span class="math notranslate nohighlight">\(n-1\)</span> input nodes connected to <code class="docutils literal notranslate"><span class="pre">data</span></code>
nodes (nodes that will contain the data tensors), and one output node,
whose physical dimension (<code class="docutils literal notranslate"><span class="pre">out_dim</span></code>) is used as the label (for
classification tasks).</p>
<p>Besides, since this class has an output edge, when contracting the whole
tensor network (with input data), the result will be a vector that can be
plugged into the next layer (being this other tensor network or a neural
network layer).</p>
<p>If the physical dimensions of all the input nodes (<code class="docutils literal notranslate"><span class="pre">in_dim</span></code>) are equal,
the input data tensor can be passed as a single tensor. Otherwise, it would
have to be passed as a list of tensors with different sizes.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>That is, <code class="docutils literal notranslate"><span class="pre">MPSLayer</span></code> is equivalent to <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a> with
<code class="docutils literal notranslate"><span class="pre">out_features</span> <span class="pre">=</span> <span class="pre">[out_position]</span></code>. However, <code class="docutils literal notranslate"><span class="pre">in_features</span></code> and
<code class="docutils literal notranslate"><span class="pre">out_features</span></code> are still free to be changed if necessary, even though
this may change the expected behaviour of the <code class="docutils literal notranslate"><span class="pre">MPSLayer</span></code>. The expected
behaviour can be recovered by setting <code class="docutils literal notranslate"><span class="pre">out_features</span> <span class="pre">=</span> <span class="pre">[out_position]</span></code>
again.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For a more detailed list of inherited properties and methods,
check <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>. That is, number of nodes
without taking into account <code class="docutils literal notranslate"><span class="pre">left_node</span></code> and <code class="docutils literal notranslate"><span class="pre">right_node</span></code>. This also
includes the output node, so if one wants to instantiate an <code class="docutils literal notranslate"><span class="pre">MPSLayer</span></code>
for a dataset with <code class="docutils literal notranslate"><span class="pre">n</span></code> features, it should be <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>,
to account for the output node.</p></li>
<li><p><strong>in_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Input dimension(s). Equivalent to the physical dimension(s) but only
for input nodes. If given as a sequence, its length should be equal to
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>, since these are the input dimensions of the input
nodes.</p></li>
<li><p><strong>out_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Output dimension (labels) for the output node. Equivalent to the
physical dimension of the output node.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code> (if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>) or <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code> (if
<code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node (including output node).</p></li>
<li><p><strong>out_position</strong> (<em>int</em><em>, </em><em>optional</em>) – Position of the output node (label). Should be between 0 and
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the output node will be located at the
middle of the MPS.</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">n_features</span></code>, <code class="docutils literal notranslate"><span class="pre">in_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">out_dim</span></code>,
<code class="docutils literal notranslate"><span class="pre">bond_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">boundary</span></code>, a list of MPS tensors can be provided.
In such case, all mentioned attributes will be inferred from the given
tensors. All tensors should be rank-3 tensors, with shape <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span>
<span class="pre">phys_dim,</span> <span class="pre">bond_dim)</span></code>. If the first and last elements are rank-2 tensors,
with shapes <code class="docutils literal notranslate"><span class="pre">(phys_dim,</span> <span class="pre">bond_dim)</span></code>, <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">phys_dim)</span></code>,
respectively, the inferred boundary conditions will be “obc”. Also, if
<code class="docutils literal notranslate"><span class="pre">tensors</span></code> contains a single element, it can be rank-1 (“obc”) or
rank-3 (“pbc”).</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (e.g. one edge for data batched, other edge for
image patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPSLayer.initialize" title="tensorkrowch.models.MPSLayer.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">MPSLayer</span></code> with same input dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps_layer</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPSLayer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">in_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">out_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x (n_features - 1) x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps_layer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 10])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MPSLayer</span></code> with different input dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps_layer</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPSLayer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">in_dim</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span>
<span class="gp">... </span>                               <span class="n">out_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span> <span class="c1"># (n_features - 1) * [batch_size x feature_size]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps_layer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 10])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.in_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPSLayer.in_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns input dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.out_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPSLayer.out_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the output dimension, that is, the number of labels in the
output node. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> for input nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.out_position">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_position</span></span><a class="headerlink" href="#tensorkrowch.models.MPSLayer.out_position" title="Permalink to this definition">#</a></dt>
<dd><p>Returns position of the output node (label).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.out_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPSLayer.out_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the output node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPSLayer.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSLayer.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes of the <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>. It can be called when
instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: Each node is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;randn_eye&quot;</span></code>: Nodes are initialized as in this
<a class="reference external" href="https://arxiv.org/abs/1605.03795">paper</a>, adding identities at the
top of random gaussian tensors. In this case, <code class="docutils literal notranslate"><span class="pre">std</span></code> should be
specified with a low value, e.g., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">1e-9</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;unit&quot;</span></code>: Nodes are initialized as stacks of random unitaries. This,
combined (at least) with an embedding of the inputs as elements of
the computational basis (<a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.discretize" title="tensorkrowch.embeddings.discretize"><code class="xref py py-func docutils literal notranslate"><span class="pre">discretize()</span></code></a>
combined with <a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.basis" title="tensorkrowch.embeddings.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;canonical&quot;`</span></code>: MPS is initialized in canonical form with a squared
norm <cite>close</cite> to the product of all the physical dimensions (if bond
dimensions are bigger than the powers of the physical dimensions,
the norm could vary). Th orthogonality center is at the output node.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of tensors to set in each of the MPS nodes. If <code class="docutils literal notranslate"><span class="pre">boundary</span></code>
is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>, all tensors should be rank-3, except the first and
last ones, which can be rank-2, or rank-1 (if the first and last are
the same). If <code class="docutils literal notranslate"><span class="pre">boundary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>, all tensors should be
rank-3.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSLayer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#MPSLayer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSLayer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied MPSLayer should be
set as the tensors in the current MPSLayer (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or cloned
(<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both MPSLayer’s will be
the same, which might be useful if one needs more than one copy
of an MPSLayer, but wants to compute all the gradients with respect
to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer">MPSLayer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="umpslayer">
<h3>UMPSLayer<a class="headerlink" href="#umpslayer" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">UMPSLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPSLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPSLayer" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform (translationally invariant) Matrix Product States with an
output node. It is the uniform version of <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>, with all input
nodes sharing the same tensor, but with a different node for the output node.
Thus this class cannot have different input or bond dimensions for each node,
and boundary conditions are always periodic (<code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For a more detailed list of inherited properties and methods,
check <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>. This also includes the
output node, so if one wants to instantiate a <code class="docutils literal notranslate"><span class="pre">UMPSLayer</span></code> for a
dataset with <code class="docutils literal notranslate"><span class="pre">n</span></code> features, it should be <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>, to
account for the output node.</p></li>
<li><p><strong>in_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Input dimension. Equivalent to the physical dimension but only for
input nodes.</p></li>
<li><p><strong>out_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Output dimension (labels) for the output node.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Bond dimension.</p></li>
<li><p><strong>out_position</strong> (<em>int</em><em>, </em><em>optional</em>) – Position of the output node (label). Should be between 0 and
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the output node will be located at the
middle of the MPS.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">in_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">out_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>, a
sequence of 2 tensors can be provided, the first one will be the uniform
tensor, and the second one will be the output node’s tensor.
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is still needed to specify how many times the uniform
tensor should be used to form a finite MPS. In this case, since the
output node will have a different tensor, the uniform tensor will be
used in the remaining <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code> input nodes. Both tensors
should be rank-3, with all their first and last dimensions being equal.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.UMPSLayer.initialize" title="tensorkrowch.models.UMPSLayer.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps_layer</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">UMPSLayer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">in_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">out_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mps_layer</span><span class="o">.</span><span class="n">mats_env</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">mps_layer</span><span class="o">.</span><span class="n">out_position</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x (n_features - 1) x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mps_layer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 10])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.in_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_dim</span></span><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.in_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns input dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.out_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_dim</span></span><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.out_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the output dimension, that is, the number of labels in the
output node. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> for input nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.out_position">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_position</span></span><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.out_position" title="Permalink to this definition">#</a></dt>
<dd><p>Returns position of the output node (label).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.out_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_node</span></span><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.out_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the output node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPSLayer.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes the common tensor of the <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>. It can be called
when instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: The tensor is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;randn_eye&quot;</span></code>: Tensor is initialized as in this
<a class="reference external" href="https://arxiv.org/abs/1605.03795">paper</a>, adding identities at the
top of a random gaussian tensor. In this case, <code class="docutils literal notranslate"><span class="pre">std</span></code> should be
specified with a low value, e.g., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">1e-9</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;unit&quot;</span></code>: Tensor is initialized as a stack of random unitaries. This,
combined (at least) with an embedding of the inputs as elements of
the computational basis (<a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.discretize" title="tensorkrowch.embeddings.discretize"><code class="xref py py-func docutils literal notranslate"><span class="pre">discretize()</span></code></a>
combined with <a class="reference internal" href="embeddings.html#tensorkrowch.embeddings.basis" title="tensorkrowch.embeddings.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;canonical&quot;`</span></code>: MPS is initialized in canonical form with a squared
norm <cite>close</cite> to the product of all the physical dimensions (if bond
dimensions are bigger than the powers of the physical dimensions,
the norm could vary).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of a 2 tensors, the first one will be the uniform tensor
that will be set in all input nodes, and the second one will be the
output node’s tensor. Both tensors should be rank-3, with all their
first and last dimensions being equal.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPSLayer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied UMPSLayer should be
set as the tensors in the current UMPSLayer (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or cloned
(<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both UMPSLayer’s will be
the same, which might be useful if one needs more than one copy
of an UMPSLayer, but wants to compute all the gradients with respect
to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer">UMPSLayer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPSLayer.parameterize">
<span class="sig-name descname"><span class="pre">parameterize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#UMPSLayer.parameterize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPSLayer.parameterize" title="Permalink to this definition">#</a></dt>
<dd><p>Parameterizes all nodes of the MPS. If there are <code class="docutils literal notranslate"><span class="pre">resultant</span></code> nodes
in the MPS, it will be first <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_param</strong> (<em>bool</em>) – Boolean indicating whether the tensor network has to be parameterized
(<code class="docutils literal notranslate"><span class="pre">True</span></code>) or de-parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><strong>override</strong> (<em>bool</em>) – Boolean indicating whether the tensor network should be parameterized
in-place (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or copied and then parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convmps">
<h3>ConvMPS<a class="headerlink" href="#convmps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvMPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvMPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvMPS" title="Permalink to this definition">#</a></dt>
<dd><p>Convolutional version of <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>, where the input data is assumed to
be a batch of images.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span> (if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>)
or <span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1 - 1\)</span> (if
<code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node.</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – To initialize MPS nodes, a list of MPS tensors can be provided. All
tensors should be rank-3 tensors, with shape <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_channels,</span>
<span class="pre">bond_dim)</span></code>. If the first and last elements are rank-2 tensors, with
shapes <code class="docutils literal notranslate"><span class="pre">(in_channels,</span> <span class="pre">bond_dim)</span></code>, <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_channels)</span></code>,
respectively, the inferred boundary conditions will be “obc”. Also, if
<code class="docutils literal notranslate"><span class="pre">tensors</span></code> contains a single element, it can be rank-1 (“obc”) or
rank-3 (“pbc”).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPS.initialize" title="tensorkrowch.models.MPS.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvMPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 1, 1])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.forward" title="tensorkrowch.TensorNetwork.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code></a> to compute a
convolution on the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>mode</strong> (<em>{&quot;flat&quot;</em><em>, </em><em>&quot;snake&quot;}</em>) – Indicates the order in which MPS should take the pixels in the image.
When <code class="docutils literal notranslate"><span class="pre">&quot;flat&quot;</span></code>, the image is flattened putting one row of the image
after the other. When <code class="docutils literal notranslate"><span class="pre">&quot;snake&quot;</span></code>, its row is put in the opposite
orientation as the previous row (like a snake running through the
image).</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline_input</span></code> or <code class="docutils literal notranslate"><span class="pre">inline_mats</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of nodes is given by
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPS.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPS.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvMPS.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvMPS.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.ConvMPS" title="tensorkrowch.models.ConvMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConvMPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied ConvMPS should be
set as the tensors in the current ConvMPS (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or cloned
(<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both ConvMPS’s will be
the same, which might be useful if one needs more than one copy
of a ConvMPS, but wants to compute all the gradients with respect
to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.ConvMPS" title="tensorkrowch.models.ConvMPS">ConvMPS</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convumps">
<h3>ConvUMPS<a class="headerlink" href="#convumps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvUMPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvUMPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUMPS" title="Permalink to this definition">#</a></dt>
<dd><p>Convolutional version of <a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPS</span></code></a>, where the input data is assumed to
be a batch of images.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UMPS" title="tensorkrowch.models.UMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPS</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em>) – Bond dimension.</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>tensor</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – To initialize MPS nodes, a MPS tensor can be provided. The tensor
should be rank-3, with its first and last dimensions being equal.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.UMPS.initialize" title="tensorkrowch.models.UMPS.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvUMPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">conv_mps</span><span class="o">.</span><span class="n">mats_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_mps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 1, 1])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.forward" title="tensorkrowch.TensorNetwork.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code></a> to compute a
convolution on the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>mode</strong> (<em>{&quot;flat&quot;</em><em>, </em><em>&quot;snake&quot;}</em>) – Indicates the order in which MPS should take the pixels in the image.
When <code class="docutils literal notranslate"><span class="pre">&quot;flat&quot;</span></code>, the image is flattened putting one row of the image
after the other. When <code class="docutils literal notranslate"><span class="pre">&quot;snake&quot;</span></code>, its row is put in the opposite
orientation as the previous row (like a snake running through the
image).</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline_input</span></code> or <code class="docutils literal notranslate"><span class="pre">inline_mats</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of nodes is given by
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPS.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvUMPS.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUMPS.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.ConvUMPS" title="tensorkrowch.models.ConvUMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConvUMPS</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether the common tensor in the copied ConvUMPS
should be set as the tensor in the current ConvUMPS (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or
cloned (<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, the tensor in both ConvUMPS’s
will be the same, which might be useful if one needs more than one
copy of a ConvUMPS, but wants to compute all the gradients with respect
to the same, unique, tensor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.ConvUMPS" title="tensorkrowch.models.ConvUMPS">ConvUMPS</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convmpslayer">
<h3>ConvMPSLayer<a class="headerlink" href="#convmpslayer" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvMPSLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvMPSLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer" title="Permalink to this definition">#</a></dt>
<dd><p>Convolutional version of <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>, where the input data is assumed to
be a batch of images.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>.</p></li>
<li><p><strong>out_channels</strong> (<em>int</em>) – Output channels. Same as <code class="docutils literal notranslate"><span class="pre">out_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1 + 1\)</span>
(if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>) or <span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span>
(if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node (including output node).</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>out_position</strong> (<em>int</em><em>, </em><em>optional</em>) – Position of the output node (label). Should be between 0 and
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the output node
will be located at the middle of the MPS.</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – To initialize MPS nodes, a list of MPS tensors can be provided. All
tensors should be rank-3 tensors, with shape <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_channels,</span>
<span class="pre">bond_dim)</span></code>. If the first and last elements are rank-2 tensors, with
shapes <code class="docutils literal notranslate"><span class="pre">(in_channels,</span> <span class="pre">bond_dim)</span></code>, <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_channels)</span></code>,
respectively, the inferred boundary conditions will be “obc”. Also, if
<code class="docutils literal notranslate"><span class="pre">tensors</span></code> contains a single element, it can be rank-1 (“obc”) or
rank-3 (“pbc”).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPSLayer.initialize" title="tensorkrowch.models.MPSLayer.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_mps_layer</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvMPSLayer</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">out_channels</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_mps_layer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 10, 1, 1])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.forward" title="tensorkrowch.TensorNetwork.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code></a> to compute a
convolution on the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>mode</strong> (<em>{&quot;flat&quot;</em><em>, </em><em>&quot;snake&quot;}</em>) – Indicates the order in which MPS should take the pixels in the image.
When <code class="docutils literal notranslate"><span class="pre">&quot;flat&quot;</span></code>, the image is flattened putting one row of the image
after the other. When <code class="docutils literal notranslate"><span class="pre">&quot;snake&quot;</span></code>, its row is put in the opposite
orientation as the previous row (like a snake running through the
image).</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline_input</span></code> or <code class="docutils literal notranslate"><span class="pre">inline_mats</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.out_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.out_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">out_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">out_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPSLayer" title="tensorkrowch.models.MPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSLayer</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of nodes is given by
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1 + 1\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvMPSLayer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvMPSLayer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvMPSLayer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.ConvMPSLayer" title="tensorkrowch.models.ConvMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConvMPSLayer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied ConvMPSLayer should
be set as the tensors in the current ConvMPSLayer (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or
cloned (<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both ConvMPSLayer’s
will be the same, which might be useful if one needs more than one
copy of an ConvMPSLayer, but wants to compute all the gradients with
respect to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.ConvMPSLayer" title="tensorkrowch.models.ConvMPSLayer">ConvMPSLayer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convumpslayer">
<h3>ConvUMPSLayer<a class="headerlink" href="#convumpslayer" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvUMPSLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvUMPSLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer" title="Permalink to this definition">#</a></dt>
<dd><p>Convolutional version of <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>, where the input data is assumed to
be a batch of images.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>.</p></li>
<li><p><strong>out_channels</strong> (<em>int</em>) – Output channels. Same as <code class="docutils literal notranslate"><span class="pre">out_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em>) – Bond dimension.</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>out_position</strong> (<em>int</em><em>, </em><em>optional</em>) – Position of the output node (label). Should be between 0 and
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the output node
will be located at the middle of the MPS.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – To initialize MPS nodes, a sequence of 2 tensors can be provided, the
first one will be the uniform tensor, and the second one will be the
output node’s tensor. Both tensors should be rank-3, with all their
first and last dimensions being equal.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;</em><em>, </em><em>&quot;randn_eye&quot;</em><em>, </em><em>&quot;unit&quot;</em><em>, </em><em>&quot;canonical&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.UMPSLayer.initialize" title="tensorkrowch.models.UMPSLayer.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more
detailed explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_mps_layer</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvUMPSLayer</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">out_channels</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conv_mps_layer</span><span class="o">.</span><span class="n">mats_env</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">conv_mps_layer</span><span class="o">.</span><span class="n">out_position</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_mps_layer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 10, 1, 1])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.forward" title="tensorkrowch.TensorNetwork.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code></a> to compute a
convolution on the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>mode</strong> (<em>{&quot;flat&quot;</em><em>, </em><em>&quot;snake&quot;}</em>) – Indicates the order in which MPS should take the pixels in the image.
When <code class="docutils literal notranslate"><span class="pre">&quot;flat&quot;</span></code>, the image is flattened putting one row of the image
after the other. When <code class="docutils literal notranslate"><span class="pre">&quot;snake&quot;</span></code>, its row is put in the opposite
orientation as the previous row (like a snake running through the
image).</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.MPS.contract" title="tensorkrowch.models.MPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline_input</span></code> or <code class="docutils literal notranslate"><span class="pre">inline_mats</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UMPSLayer" title="tensorkrowch.models.UMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPSLayer</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of nodes is given by
<span class="math notranslate nohighlight">\(kernel\_size_0 \cdot kernel\_size_1 + 1\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.out_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.out_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">out_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUMPSLayer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps.html#ConvUMPSLayer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUMPSLayer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.ConvUMPSLayer" title="tensorkrowch.models.ConvUMPSLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConvUMPSLayer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied ConvUMPSLayer should
be set as the tensors in the current ConvUMPSLayer (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or
cloned (<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both ConvUMPSLayer’s
will be the same, which might be useful if one needs more than one
copy of an ConvUMPSLayer, but wants to compute all the gradients with
respect to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.ConvUMPSLayer" title="tensorkrowch.models.ConvUMPSLayer">ConvUMPSLayer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="mpsdata">
<h2>MPSData<a class="headerlink" href="#mpsdata" title="Permalink to this headline">#</a></h2>
<section id="id35">
<h3>MPSData<a class="headerlink" href="#id35" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">MPSData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phys_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps_data.html#MPSData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSData" title="Permalink to this definition">#</a></dt>
<dd><p>Class for data vectors in the form of Matrix Product States. That is, this
is a class similar to <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>, but where all nodes can have additional
batch edges.</p>
<p>Besides, since this class is intended to store data vectors, all
<a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">nodes</span></code></a> are non-parametric, and are <code class="docutils literal notranslate"><span class="pre">data</span></code>
nodes. Also, this class does not have an inherited <code class="docutils literal notranslate"><span class="pre">contract</span></code> method,
since it is not intended to be contracted with input data, but rather
act itself as input data of another tensor network model.</p>
<p>Similar to <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>, <code class="docutils literal notranslate"><span class="pre">MPSData</span></code> is formed by:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mats_env</span></code>: Environment of <cite>matrix</cite> nodes with axes
<code class="docutils literal notranslate"><span class="pre">(&quot;batch_0&quot;,</span> <span class="pre">...,</span> <span class="pre">&quot;batch_n&quot;,</span> <span class="pre">&quot;left&quot;,</span> <span class="pre">&quot;feature&quot;,</span> <span class="pre">&quot;right&quot;)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_node</span></code>, <code class="docutils literal notranslate"><span class="pre">right_node</span></code>: <cite>Vector</cite> nodes with axes <code class="docutils literal notranslate"><span class="pre">(&quot;right&quot;,)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,)</span></code>, respectively. These are used to close the boundary
in the case <code class="docutils literal notranslate"><span class="pre">boudary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>. Otherwise, both are <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>Since <code class="docutils literal notranslate"><span class="pre">MPSData</span></code> is designed to store input data vectors, this can be
accomplished by calling the custom <a class="reference internal" href="#tensorkrowch.models.MPSData.add_data" title="tensorkrowch.models.MPSData.add_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_data()</span></code></a> method with a given
list of tensors. This is in contrast to the usual way of setting nodes’
tensors in <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a> and its derived classes via <a class="reference internal" href="#tensorkrowch.models.MPS.initialize" title="tensorkrowch.models.MPS.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MPS.initialize()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>. That is, number of nodes
without taking into account <code class="docutils literal notranslate"><span class="pre">left_node</span></code> and <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p></li>
<li><p><strong>phys_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Physical dimension(s). If given as a sequence, its length should be
equal to <code class="docutils literal notranslate"><span class="pre">n_features</span></code>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code> (if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>) or <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code> (if
<code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node.</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of the MPS nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">n_features</span></code>, <code class="docutils literal notranslate"><span class="pre">phys_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code> and
<code class="docutils literal notranslate"><span class="pre">boundary</span></code>, a list of MPS tensors can be provided. In such case, all
mentioned attributes will be inferred from the given tensors. All
tensors should be rank-(n+3) tensors, with shape
<code class="docutils literal notranslate"><span class="pre">(batch_1,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">bond_dim,</span> <span class="pre">phys_dim,</span> <span class="pre">bond_dim)</span></code>. If the first
and last elements are rank-(n+2) tensors, with shapes
<code class="docutils literal notranslate"><span class="pre">(batch_1,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">phys_dim,</span> <span class="pre">bond_dim)</span></code>,
<code class="docutils literal notranslate"><span class="pre">(batch_1,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">bond_dim,</span> <span class="pre">phys_dim)</span></code>, respectively,
the inferred boundary conditions will be “obc”. Also, if <code class="docutils literal notranslate"><span class="pre">tensors</span></code>
contains a single element, it can be rank-(n+1) (“obc”) or rank-(n+3)
(“pbc”).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPSData.initialize" title="tensorkrowch.models.MPSData.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods. By default it is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, since <code class="docutils literal notranslate"><span class="pre">MPSData</span></code> is intended to store input data vectors in
MPS form, rather than initializing its own random tensors. Check
<a class="reference internal" href="#tensorkrowch.models.MPSData.add_data" title="tensorkrowch.models.MPSData.add_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_data()</span></code></a> to see how to initialize MPS nodes with data tensors.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPSData</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">phys_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;pbc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n_features * (batch_size x bond_dim x feature_size x bond_dim)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mps</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">mps</span><span class="o">.</span><span class="n">mats_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.n_features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_features</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.n_features" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.phys_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">phys_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.phys_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns physical dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.boundary" title="Permalink to this definition">#</a></dt>
<dd><p>Returns boundary condition (“obc” or “pbc”).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the MPS nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.left_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">left_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.left_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">left_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.right_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">right_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.right_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.mats_env">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mats_env</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.mats_env" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of nodes in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.tensors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tensors</span></span><a class="headerlink" href="#tensorkrowch.models.MPSData.tensors" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of MPS tensors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps_data.html#MPSData.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSData.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes of the <a class="reference internal" href="#tensorkrowch.models.MPSData" title="tensorkrowch.models.MPSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSData</span></code></a>. It can be called when
instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: Each node is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPSData.add_data" title="tensorkrowch.models.MPSData.add_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_data()</span></code></a> to see how to
initialize MPS nodes with data tensors.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPSData.add_data">
<span class="sig-name descname"><span class="pre">add_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mps_data.html#MPSData.add_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPSData.add_data" title="Permalink to this definition">#</a></dt>
<dd><p>Adds data to MPS data nodes. Input is a list of mps tensors.</p>
<p>The physical dimensions of the given data tensors should coincide with
the physical dimensions of the MPS. The bond dimensions can be different.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em>) – A sequence of tensors, one for each of the MPS nodes. If <code class="docutils literal notranslate"><span class="pre">boundary</span></code>
is <code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>, all tensors should have the same rank, with shapes
<code class="docutils literal notranslate"><span class="pre">(batch_0,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">bond_dim,</span> <span class="pre">phys_dim,</span> <span class="pre">bond_dim)</span></code>. If
<code class="docutils literal notranslate"><span class="pre">boundary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>, the first and last tensors should have
shapes <code class="docutils literal notranslate"><span class="pre">(batch_0,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">phys_dim,</span> <span class="pre">bond_dim)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(batch_0,</span> <span class="pre">...,</span> <span class="pre">batch_n,</span> <span class="pre">bond_dim,</span> <span class="pre">phys_dim)</span></code>, respectively.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="mpo">
<h2>MPO<a class="headerlink" href="#mpo" title="Permalink to this headline">#</a></h2>
<section id="id36">
<h3>MPO<a class="headerlink" href="#id36" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">MPO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'obc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Matrix Product Operators. This is the base class from which
<a class="reference internal" href="#tensorkrowch.models.UMPO" title="tensorkrowch.models.UMPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPO</span></code></a> inherits.</p>
<p>Matrix Product Operators are formed by:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mats_env</span></code>: Environment of <cite>matrix</cite> nodes with axes
<code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;input&quot;,</span> <span class="pre">&quot;right&quot;,</span> <span class="pre">&quot;output&quot;)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_node</span></code>, <code class="docutils literal notranslate"><span class="pre">right_node</span></code>: <cite>Vector</cite> nodes with axes <code class="docutils literal notranslate"><span class="pre">(&quot;right&quot;,)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,)</span></code>, respectively. These are used to close the boundary
in the case <code class="docutils literal notranslate"><span class="pre">boudary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>. Otherwise, both are <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>In contrast with <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>, in <code class="docutils literal notranslate"><span class="pre">MPO</span></code> all nodes act both as input and
output, with corresponding edges dedicated to that. Thus, data nodes will
be connected to the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code> edge of all nodes. Upon contraction of the
whole network, a resultant tensor will be formed, with as many dimensions
as nodes were in the MPO.</p>
<p>If all nodes have the same input dimensions, the input data tensor can be
passed as a single tensor. Otherwise, it would have to be passed as a list
of tensors with different sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>. That is, number of nodes
without taking into account <code class="docutils literal notranslate"><span class="pre">left_node</span></code> and <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p></li>
<li><p><strong>in_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Input dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code>.</p></li>
<li><p><strong>out_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Output dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code>.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – Bond dimension(s). If given as a sequence, its length should be equal
to <code class="docutils literal notranslate"><span class="pre">n_features</span></code> (if <code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;pbc&quot;</span></code>) or <code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code> (if
<code class="docutils literal notranslate"><span class="pre">boundary</span> <span class="pre">=</span> <span class="pre">&quot;obc&quot;</span></code>). The i-th bond dimension is always the dimension
of the right edge of the i-th node.</p></li>
<li><p><strong>boundary</strong> (<em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em>) – String indicating whether periodic or open boundary conditions should
be used.</p></li>
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">n_features</span></code>, <code class="docutils literal notranslate"><span class="pre">in_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">in_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>
and <code class="docutils literal notranslate"><span class="pre">boundary</span></code>, a list of MPO tensors can be provided. In such case,
all mentioned attributes will be inferred from the given tensors. All
tensors should be rank-4 tensors, with shape <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_dim,</span>
<span class="pre">bond_dim,</span> <span class="pre">out_dim)</span></code>. If the first and last elements are rank-3 tensors,
with shapes <code class="docutils literal notranslate"><span class="pre">(in_dim,</span> <span class="pre">bond_dim,</span> <span class="pre">out_dim)</span></code>, <code class="docutils literal notranslate"><span class="pre">(bond_dim,</span> <span class="pre">in_dim,</span> <span class="pre">out_dim)</span></code>,
respectively, the inferred boundary conditions will be “obc”. Also, if
<code class="docutils literal notranslate"><span class="pre">tensors</span></code> contains a single element, it can be rank-2 (“obc”) or
rank-4 (“pbc”).</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.MPO.initialize" title="tensorkrowch.models.MPO.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">MPO</span></code> with same input/output dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPO</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">in_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">out_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mpo</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 2, 2, 2, 2, 2])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MPO</span></code> with different input/physical dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPO</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">in_dim</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span>
<span class="gp">... </span>                    <span class="n">out_dim</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span> <span class="c1"># n_features * [batch_size x feature_size]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mpo</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 7, 6, 5, 4, 3])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.n_features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_features</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.n_features" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.in_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.in_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns input dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.out_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.out_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns output dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.boundary" title="Permalink to this definition">#</a></dt>
<dd><p>Returns boundary condition (“obc” or “pbc”).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. To change this
attribute, first call <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.unset_data_nodes" title="tensorkrowch.TensorNetwork.unset_data_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unset_data_nodes()</span></code></a>
if there are already data nodes in the network.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.left_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">left_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.left_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">left_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.right_node">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">right_node</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.right_node" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">right_node</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.mats_env">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mats_env</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.mats_env" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of nodes in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.tensors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tensors</span></span><a class="headerlink" href="#tensorkrowch.models.MPO.tensors" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of MPO tensors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes of the <a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>. It can be called when
instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: Each node is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of tensors to set in each of the MPO nodes. If <code class="docutils literal notranslate"><span class="pre">boundary</span></code>
is <code class="docutils literal notranslate"><span class="pre">&quot;obc&quot;</span></code>, all tensors should be rank-4, except the first and
last ones, which can be rank-3, or rank-2 (if the first and last are
the same). If <code class="docutils literal notranslate"><span class="pre">boundary</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>, all tensors should be
rank-4.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes and connects each of them to the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edge of each node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether tensors in the copied MPO should be
set as the tensors in the current MPO (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or cloned
(<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, tensors in both MPO’s will be
the same, which might be useful if one needs more than one copy
of an MPO, but wants to compute all the gradients with respect
to the same, unique, tensors.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO">MPO</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.parameterize">
<span class="sig-name descname"><span class="pre">parameterize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.parameterize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.parameterize" title="Permalink to this definition">#</a></dt>
<dd><p>Parameterizes all nodes of the MPO. If there are <code class="docutils literal notranslate"><span class="pre">resultant</span></code> nodes
in the MPO, it will be first <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_param</strong> (<em>bool</em>) – Boolean indicating whether the tensor network has to be parameterized
(<code class="docutils literal notranslate"><span class="pre">True</span></code>) or de-parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><strong>override</strong> (<em>bool</em>) – Boolean indicating whether the tensor network should be parameterized
in-place (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or copied and then parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.update_bond_dim">
<span class="sig-name descname"><span class="pre">update_bond_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.update_bond_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.update_bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the <a class="reference internal" href="#tensorkrowch.models.MPO.bond_dim" title="tensorkrowch.models.MPO.bond_dim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_dim</span></code></a> attribute of the <code class="docutils literal notranslate"><span class="pre">MPO</span></code>, in case it is
outdated.</p>
<p>If bond dimensions are changed, usually due to decompositions like
<a class="reference internal" href="operations.html#tensorkrowch.svd" title="tensorkrowch.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">update_bond_dim</span></code> should be
called. This might modify some elements of the model, so it is
recommended to do this before saving the <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> of the model.
Besides, if one wants to continue training, the <code class="docutils literal notranslate"><span class="pre">parameters</span></code> of the
model that are passed to the optimizer should be updated also.
Otherwise, the optimizer could be tracking outdated parameters that are
not members of the model any more.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inline_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline_mats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole MPO with input data nodes. The input can be in the
form of an <a class="reference internal" href="#tensorkrowch.models.MPSData" title="tensorkrowch.models.MPSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSData</span></code></a>, which may be convenient for tensorizing
vector-matrix multiplication in the form of MPS-MPO contraction.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">MPO</span></code> is contracted with a <code class="docutils literal notranslate"><span class="pre">MPSData</span></code>, MPS nodes will become
part of the MPO network, and they will be connected to the <code class="docutils literal notranslate"><span class="pre">&quot;input&quot;</span></code>
edges of the MPO. Thus, the MPS and the MPO should have the same number
of features (<code class="docutils literal notranslate"><span class="pre">n_features</span></code>).</p>
<p>Even though it is not necessary to connect the <code class="docutils literal notranslate"><span class="pre">MPSData</span></code> nodes to the
MPO nodes by hand before contraction, it can be done. However, one
should first move the MPS nodes to the MPO network.</p>
<p>Also, when contracting the MPO with and <code class="docutils literal notranslate"><span class="pre">MPSData</span></code>, if any of the
contraction arguments, <code class="docutils literal notranslate"><span class="pre">inline_input</span></code> or <code class="docutils literal notranslate"><span class="pre">inline_mats</span></code>, is set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the MPO (already connected to the MPS) should be
<a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> before contraction if new
data is set into the <code class="docutils literal notranslate"><span class="pre">MPSData</span></code> nodes. This is because <a class="reference internal" href="#tensorkrowch.models.MPSData" title="tensorkrowch.models.MPSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSData</span></code></a>
admits data tensors with different bond dimensions for each iteration,
and this may cause undesired behaviour when reusing some information of
previous calls to :func:~tensorkrowch.stack` with the previous data
tensors.</p>
<p>To perform the MPS-MPO contraction, first input data tensors have to
be put into the <a class="reference internal" href="#tensorkrowch.models.MPSData" title="tensorkrowch.models.MPSData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPSData</span></code></a> via <a class="reference internal" href="#tensorkrowch.models.MPSData.add_data" title="tensorkrowch.models.MPSData.add_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MPSData.add_data()</span></code></a>. Then,
contraction is carried out by calling <code class="docutils literal notranslate"><span class="pre">mpo(mps=mps_data)</span></code>, without
passing the input data again, as it is already stored in the MPSData
nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inline_input</strong> (<em>bool</em>) – Boolean indicating whether input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes should be contracted
with the <code class="docutils literal notranslate"><span class="pre">MPO</span></code> nodes inline (one contraction at a time) or in a
single stacked contraction.</p></li>
<li><p><strong>inline_mats</strong> (<em>bool</em>) – Boolean indicating whether the sequence of matrices (resultant
after contracting the input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes) should be contracted
inline or as a sequence of pairwise stacked contrations.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after contraction.
If not, it may happen that the norm explodes or vanishes, as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale. The renormalization only occurs when multiplying
sequences of matrices, once the <cite>input</cite> contractions have been
already performed, including contracting against <code class="docutils literal notranslate"><span class="pre">MPSData</span></code>.</p></li>
<li><p><strong>mps</strong> (<a class="reference internal" href="#tensorkrowch.models.MPSData" title="tensorkrowch.models.MPSData"><em>MPSData</em></a><em>, </em><em>optional</em>) – MPS that is to be contracted with the MPO. New data can be
put into the MPS via <a class="reference internal" href="#tensorkrowch.models.MPSData.add_data" title="tensorkrowch.models.MPSData.add_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MPSData.add_data()</span></code></a>, and the MPS-MPO
contraction is performed by calling <code class="docutils literal notranslate"><span class="pre">mpo(mps=mps_data)</span></code>, without
passing the input data again, as it is already stored in the MPS
cores.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.MPO.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'svd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cum_percentage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#MPO.canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.MPO.canonicalize" title="Permalink to this definition">#</a></dt>
<dd><p>Turns MPO into <cite>canonical</cite> form via local SVD/QR decompositions in the
same way this transformation is applied to <a class="reference internal" href="#tensorkrowch.models.MPS" title="tensorkrowch.models.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
<p>To specify the new bond dimensions, the arguments <code class="docutils literal notranslate"><span class="pre">rank</span></code>,
<code class="docutils literal notranslate"><span class="pre">cum_percentage</span></code> or <code class="docutils literal notranslate"><span class="pre">cutoff</span></code> can be specified. These will be used
equally for all SVD computations.</p>
<p>If none of them are specified, the bond dimensions won’t be modified
if possible. Only when the bond dimension is bigger than the physical
dimension multiplied by the other bond dimension of the node, it will
be cropped to that size.</p>
<p>If rank is not specified, the current bond dimensions will be used as
the rank. That is, the current bond dimensions will be the upper bound
for the possibly new bond dimensions given by the arguments
<code class="docutils literal notranslate"><span class="pre">cum_percentage</span></code> and/or <code class="docutils literal notranslate"><span class="pre">cutoff</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oc</strong> (<em>int</em>) – Position of the orthogonality center. It should be between 0 and
<code class="docutils literal notranslate"><span class="pre">n_features</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>mode</strong> (<em>{&quot;svd&quot;</em><em>, </em><em>&quot;svdr&quot;</em><em>, </em><em>&quot;qr&quot;}</em>) – Indicates which decomposition should be used to split a node after
contracting it. See more at <a class="reference internal" href="operations.html#tensorkrowch.svd_" title="tensorkrowch.svd_"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd_()</span></code></a>,
<a class="reference internal" href="operations.html#tensorkrowch.svdr_" title="tensorkrowch.svdr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">svdr_()</span></code></a>, <a class="reference internal" href="operations.html#tensorkrowch.qr_" title="tensorkrowch.qr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code></a>.
If mode is “qr”, operation <a class="reference internal" href="operations.html#tensorkrowch.qr_" title="tensorkrowch.qr_"><code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code></a> will be
performed on nodes at the left of the output node, whilst operation
<a class="reference internal" href="operations.html#tensorkrowch.rq_" title="tensorkrowch.rq_"><code class="xref py py-func docutils literal notranslate"><span class="pre">rq_()</span></code></a> will be used for nodes at the right.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of singular values to keep.</p></li>
<li><p><strong>cum_percentage</strong> (<em>float</em><em>, </em><em>optional</em>) – <p>Proportion that should be satisfied between the sum of all singular
values kept and the total sum of all singular values.</p>
<div class="math notranslate nohighlight">
\[\frac{\sum_{i \in \{kept\}}{s_i}}{\sum_{i \in \{all\}}{s_i}} \ge
cum\_percentage\]</div>
</p></li>
<li><p><strong>cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Quantity that lower bounds singular values in order to be kept.</p></li>
<li><p><strong>renormalize</strong> (<em>bool</em>) – Indicates whether nodes should be renormalized after SVD/QR
decompositions. If not, it may happen that the norm explodes as it
is being accumulated from all nodes. Renormalization aims to avoid
this undesired behavior by extracting the norm of each node on a
logarithmic scale after SVD/QR decompositions are computed. Finally,
the normalization factor is evenly distributed among all nodes of
the MPO.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">MPO</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">in_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">out_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span><span class="o">.</span><span class="n">bond_dim</span>
<span class="go">[3, 3, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="umpo">
<h3>UMPO<a class="headerlink" href="#umpo" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">UMPO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#UMPO"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPO" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform (translationally invariant) Matrix Product Operators. It is
the uniform version of <a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>, that is, all nodes share the same
tensor. Thus this class cannot have different input/output or bond dimensions
for each node, and boundary conditions are always periodic (<code class="docutils literal notranslate"><span class="pre">&quot;pbc&quot;</span></code>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For a more detailed list of inherited properties and methods,
check <a class="reference internal" href="#tensorkrowch.models.MPO" title="tensorkrowch.models.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_features</strong> (<em>int</em>) – Number of nodes that will be in <code class="docutils literal notranslate"><span class="pre">mats_env</span></code>.</p></li>
<li><p><strong>in_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Input dimension.</p></li>
<li><p><strong>out_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Output dimension.</p></li>
<li><p><strong>bond_dim</strong> (<em>int</em><em>, </em><em>optional</em>) – Bond dimension.</p></li>
<li><p><strong>tensor</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Instead of providing <code class="docutils literal notranslate"><span class="pre">in_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">out_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>, a single
tensor can be provided. <code class="docutils literal notranslate"><span class="pre">n_features</span></code> is still needed to specify how
many times the tensor should be used to form a finite MPO. The tensor
should be rank-4, with its first and third dimensions being equal.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method. Check <a class="reference internal" href="#tensorkrowch.models.UMPO.initialize" title="tensorkrowch.models.UMPO.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> for a more detailed
explanation of the different initialization methods.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mpo</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">UMPO</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">in_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">out_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">bond_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">mpo</span><span class="o">.</span><span class="n">mats_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">mpo</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 2, 2, 2, 2])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPO.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'randn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#UMPO.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPO.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes the common tensor of the <a class="reference internal" href="#tensorkrowch.models.UMPO" title="tensorkrowch.models.UMPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPO</span></code></a>. It can be called
when instantiating the model, or to override the existing nodes’ tensors.</p>
<p>There are different methods to initialize the nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{&quot;zeros&quot;,</span> <span class="pre">&quot;ones&quot;,</span> <span class="pre">&quot;copy&quot;,</span> <span class="pre">&quot;rand&quot;,</span> <span class="pre">&quot;randn&quot;}</span></code>: The tensor is
initialized calling <a class="reference internal" href="components.html#tensorkrowch.AbstractNode.set_tensor" title="tensorkrowch.AbstractNode.set_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_tensor()</span></code></a> with
the given method, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype</span></code> and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensors</strong> (<em>list</em><em>[</em><em>torch.Tensor</em><em>] or </em><em>tuple</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>optional</em>) – Sequence of a single tensor to set in each of the MPO nodes. The
tensor should be rank-4, with its first and third dimensions being
equal.</p></li>
<li><p><strong>init_method</strong> (<em>{&quot;zeros&quot;</em><em>, </em><em>&quot;ones&quot;</em><em>, </em><em>&quot;copy&quot;</em><em>, </em><em>&quot;rand&quot;</em><em>, </em><em>&quot;randn&quot;}</em><em>, </em><em>optional</em>) – Initialization method.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>optional</em>) – Device where to initialize the tensors if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em><em>, </em><em>optional</em>) – Dtype of the tensor if <code class="docutils literal notranslate"><span class="pre">init_method</span></code> is provided.</p></li>
<li><p><strong>kwargs</strong> (<em>float</em>) – Keyword arguments for the different initialization methods. See
<a class="reference internal" href="components.html#tensorkrowch.AbstractNode.make_tensor" title="tensorkrowch.AbstractNode.make_tensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_tensor()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPO.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">share_tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#UMPO.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPO.copy" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a copy of the <a class="reference internal" href="#tensorkrowch.models.UMPO" title="tensorkrowch.models.UMPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMPO</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>share_tensor</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean indicating whether the common tensor in the copied UMPO
should be set as the tensor in the current UMPO (<code class="docutils literal notranslate"><span class="pre">True</span></code>), or
cloned (<code class="docutils literal notranslate"><span class="pre">False</span></code>). In the former case, the tensor in both UMPO’s
will be the same, which might be useful if one needs more than one
copy of a UMPO, but wants to compute all the gradients with respect
to the same, unique, tensor.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tensorkrowch.models.UMPO" title="tensorkrowch.models.UMPO">UMPO</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UMPO.parameterize">
<span class="sig-name descname"><span class="pre">parameterize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/mpo.html#UMPO.parameterize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UMPO.parameterize" title="Permalink to this definition">#</a></dt>
<dd><p>Parameterizes all nodes of the MPO. If there are <code class="docutils literal notranslate"><span class="pre">resultant</span></code> nodes
in the MPO, it will be first <a class="reference internal" href="components.html#tensorkrowch.TensorNetwork.reset" title="tensorkrowch.TensorNetwork.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>set_param</strong> (<em>bool</em>) – Boolean indicating whether the tensor network has to be parameterized
(<code class="docutils literal notranslate"><span class="pre">True</span></code>) or de-parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p><strong>override</strong> (<em>bool</em>) – Boolean indicating whether the tensor network should be parameterized
in-place (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or copied and then parameterized (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="tree">
<h2>Tree<a class="headerlink" href="#tree" title="Permalink to this headline">#</a></h2>
<section id="id37">
<h3>Tree<a class="headerlink" href="#id37" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">Tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sites_per_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#Tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.Tree" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Tree States. These states form a tree structure where the <code class="docutils literal notranslate"><span class="pre">data</span></code>
nodes are in the base. All nodes have a sequence of input edges and an
output edge. Thus the contraction of the Tree returns a <cite>vector</cite> node.</p>
<p>All nodes in the network are in <code class="docutils literal notranslate"><span class="pre">self.layers</span></code>, a list containing the lists
of nodes in each layer (starting from the bottom).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sites_per_layer</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Number of sites in each layer of the tree. All nodes in the same layer
have the same shape. Number of nodes in each layer times the number of
input edges these have should match the number ot output edges in the
previous layer. The last element of <code class="docutils literal notranslate"><span class="pre">sites_per_layer</span></code> should be always
1, which corresponds to the output node.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>list</em><em>[</em><em>int</em><em>]</em><em>] or </em><em>tuple</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>]</em>) – Bond dimensions of nodes in each layer. Each sequence corresponds to the
shape of the nodes in each layer, starting from the bottom (some input
edges and an output edge in the last position).</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">sites_per_layer</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">bond_dim</span><span class="o">=</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 2])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.sites_per_layer">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sites_per_layer</span></span><a class="headerlink" href="#tensorkrowch.models.Tree.sites_per_layer" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of sites in each layer of the tree.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.Tree.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions of nodes in each layer. Each sequence
corresponds to the shape of the nodes in each layer (some input edges
and an output edge in the last position).</p>
<p>It can have two forms:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[shape_all_nodes_layer_1,</span> <span class="pre">...,</span> <span class="pre">shape_all_nodes_layer_N]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[[shape_node_1_layer_1,</span> <span class="pre">...,</span> <span class="pre">shape_node_i1_layer_1],</span> <span class="pre">...,</span>
<span class="pre">[shape_node_1_layer_N,</span> <span class="pre">...,</span> <span class="pre">shape_node_iN_layer_N]]</span></code></p></li>
</ol>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.Tree.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#Tree.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.Tree.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#Tree.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.Tree.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates data nodes and connects each of them to the physical edge of
an input node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#Tree.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.Tree.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole Tree Tensor Network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inline</strong> (<em>bool</em>) – Boolean indicating whether consecutive layers should be contracted
inline or in parallel (using a single stacked contraction).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.Tree.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'svd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cum_percentage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#Tree.canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.Tree.canonicalize" title="Permalink to this definition">#</a></dt>
<dd><p>Turns Tree into canonical form via local SVD/QR decompositions, moving
singular values matrices or non-isometries to the upper layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<em>{&quot;svd&quot;</em><em>, </em><em>&quot;svdr&quot;</em><em>, </em><em>&quot;qr&quot;}</em>) – Indicates which decomposition should be used to split a node after
contracting it. See more at <code class="xref py py-func docutils literal notranslate"><span class="pre">svd_()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">svdr_()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code>.
If mode is “qr”, operation <code class="xref py py-func docutils literal notranslate"><span class="pre">qr_()</span></code> will be performed on nodes at
the left of the output node, whilst operation <code class="xref py py-func docutils literal notranslate"><span class="pre">rq_()</span></code> will be
used for nodes at the right.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of singular values to keep.</p></li>
<li><p><strong>cum_percentage</strong> (<em>float</em><em>, </em><em>optional</em>) – <p>Proportion that should be satisfied between the sum of all singular
values kept and the total sum of all singular values.</p>
<div class="math notranslate nohighlight">
\[\frac{\sum_{i \in \{kept\}}{s_i}}{\sum_{i \in \{all\}}{s_i}} \ge
cum\_percentage\]</div>
</p></li>
<li><p><strong>cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Quantity that lower bounds singular values in order to be kept.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">sites_per_layer</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="n">bond_dim</span><span class="o">=</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">bond_dim</span>
<span class="go">[[[3, 3, 2], [3, 3, 2], [3, 3, 2], [3, 3, 2]], [[2, 2, 2], [2, 2, 2]], [[2, 2, 2]]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="utree">
<h3>UTree<a class="headerlink" href="#utree" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">UTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sites_per_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#UTree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UTree" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform Tree States where all nodes have the same shape. It is
the uniform version of <a class="reference internal" href="#tensorkrowch.models.Tree" title="tensorkrowch.models.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a>, that is, all nodes share the same
tensor.</p>
<p>All nodes in the network are in <code class="docutils literal notranslate"><span class="pre">self.layers</span></code>, a list containing the lists
of nodes in each layer (starting from the bottom).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sites_per_layer</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Number of sites in each layer of the tree. All nodes have the same
shape. Number of nodes in each layer times the number of input edges
these have should match the number ot output edges in the previous
layer. The last element of <code class="docutils literal notranslate"><span class="pre">sites_per_layer</span></code> should be always 1,
which corresponds to the output node.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions of nodes in each layer. Since all nodes have the same
shape, it is enough to pass a single sequence of dimensions (some input
edges and an output edge in the last position).</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">UTree</span><span class="p">(</span><span class="n">sites_per_layer</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 3])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.sites_per_layer">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sites_per_layer</span></span><a class="headerlink" href="#tensorkrowch.models.UTree.sites_per_layer" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of sites in each layer of the tree.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.UTree.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions of nodes in each layer. Since all nodes have
the same shape, it is a single sequence of dimensions (some input edges
and an output edge in the last position).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.UTree.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#UTree.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UTree.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#UTree.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UTree.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates data nodes and connects each of them to the physical edge of
an input node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UTree.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#UTree.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UTree.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole Tree Tensor Network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inline</strong> (<em>bool</em>) – Boolean indicating whether consecutive layers should be contracted
inline or in parallel (using a single stacked contraction).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convtree">
<h3>ConvTree<a class="headerlink" href="#convtree" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sites_per_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#ConvTree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvTree" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Tree States where the input data is a batch of images. It is the
convolutional version of <a class="reference internal" href="#tensorkrowch.models.Tree" title="tensorkrowch.models.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a>.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sites_per_layer</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Number of sites in each layer of the tree. All nodes in the same layer
have the same shape. Number of nodes in each layer times the number of
input edges these have should match the number ot output edges in the
previous layer.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>list</em><em>[</em><em>int</em><em>]</em><em>] or </em><em>tuple</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>]</em><em>]</em>) – Bond dimensions of nodes in each layer. Each sequence corresponds to the
shape of the nodes in each layer (some input edges and an output edge in
the last position).</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_tree</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvTree</span><span class="p">(</span><span class="n">sites_per_layer</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                               <span class="n">bond_dim</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>
<span class="gp">... </span>                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_tree</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">torch.Size([20, 5, 1, 1])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvTree.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as the first elements in <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>
from <a class="reference internal" href="#tensorkrowch.models.Tree" title="tensorkrowch.models.Tree"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tree</span></code></a>, corresponding to dimensions of the input.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvTree.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>, corresponding to number of <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvTree.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvTree.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvTree.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvTree.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#ConvTree.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvTree.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>’s forward to compute a convolution on the
input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.Tree.contract" title="tensorkrowch.models.Tree.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.Tree.contract" title="tensorkrowch.models.Tree.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convutree">
<h3>ConvUTree<a class="headerlink" href="#convutree" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvUTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sites_per_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#ConvUTree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUTree" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform Tree States where the input data is a batch of images. It
is the convolutional version of <a class="reference internal" href="#tensorkrowch.models.UTree" title="tensorkrowch.models.UTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">UTree</span></code></a>.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sites_per_layer</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Number of sites in each layer of the tree. All nodes have the same
shape. Number of nodes in each layer times the number of input edges
these have should match the number ot output edges in the previous
layer.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions of nodes in each layer. Since all nodes have the same
shape, it is enough to pass a single sequence of dimensions (some input
edges and an output edge in the last position).</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_tree</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvUTree</span><span class="p">(</span><span class="n">sites_per_layer</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                                <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                                <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">conv_tree</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_tree</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">torch.Size([20, 2, 1, 1])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUTree.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as the first elements in <code class="docutils literal notranslate"><span class="pre">bond_dim</span></code>
from <a class="reference internal" href="#tensorkrowch.models.UTree" title="tensorkrowch.models.UTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">UTree</span></code></a>, corresponding to dimensions of the input.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUTree.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>, corresponding to number of <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUTree.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUTree.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUTree.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUTree.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/tree.html#ConvUTree.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUTree.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>’s forward to compute a convolution on the
input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.UTree.contract" title="tensorkrowch.models.UTree.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.UTree.contract" title="tensorkrowch.models.UTree.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="peps">
<h2>PEPS<a class="headerlink" href="#peps" title="Permalink to this headline">#</a></h2>
<section id="id54">
<h3>PEPS<a class="headerlink" href="#id54" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">PEPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_rows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['obc',</span> <span class="pre">'obc']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#PEPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.PEPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Projected Entangled Pair States, where all nodes are input nodes,
that is, they are all connected to <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes that will store the input
data tensor(s). When contracting the PEPS with new input data, the result
will be a just a number.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">PEPS</span></code> is formed by the following nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">left_up_corner</span></code>, <code class="docutils literal notranslate"><span class="pre">left_down_corner</span></code>, <code class="docutils literal notranslate"><span class="pre">right_up_corner</span></code>,
<code class="docutils literal notranslate"><span class="pre">right_down_corner</span></code>: Corner nodes with 3 edges, the one corresponding
to the input and 2 connected to the borders.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_border</span></code>, <code class="docutils literal notranslate"><span class="pre">right_border</span></code>, <code class="docutils literal notranslate"><span class="pre">up_border</span></code>, <code class="docutils literal notranslate"><span class="pre">down_border</span></code>: Border
nodes with 4 edges, the one corresponding to the input, 2 connected to
the neighbours in the border, and 1 connected to the <cite>interior</cite> of the
grid.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grid_env</span></code>: Grid environment of nodes with 5 edges, (“input”, “left”,
“right”, “up”, “down”). Is is a list of lists of nodes.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_rows</strong> (<em>int</em>) – Number of rows of the 2D grid.</p></li>
<li><p><strong>n_cols</strong> (<em>int</em>) – Number of columns of the 2D grid.</p></li>
<li><p><strong>in_dim</strong> (<em>int</em>) – Input dimension. Equivalent to the physical dimension.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions for horizontal and vertical edges (in that order). Thus
it should contain 2 elements.</p></li>
<li><p><strong>boundary</strong> (<em>list</em><em>[</em><em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em><em>]</em>) – List of strings indicating whether periodic or open boundary conditions
should be used in the horizontal (up and down) and vertical (left and
right) boundaries.</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">PEPS</span><span class="p">(</span><span class="n">n_rows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">n_cols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">in_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">peps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.n_rows">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_rows</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.n_rows" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of rows of the 2D grid.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.n_cols">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_cols</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.n_cols" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of columns of the 2D grid.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.boundary">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">boundary</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.boundary" title="Permalink to this definition">#</a></dt>
<dd><p>Returns boundary conditions in the horizontal (up and down) and
vertical (left and right) boundaries.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.in_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_dim</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.in_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns input/physical dimension.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions for horizontal and vertical edges.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.PEPS.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#PEPS.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.PEPS.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#PEPS.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.PEPS.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates data nodes and connects each of them to the physical edge of
an input node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.PEPS.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'up'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_bond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#PEPS.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.PEPS.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole PEPS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_side</strong> (<em>{&quot;up&quot;</em><em>, </em><em>&quot;down&quot;</em><em>, </em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;}</em>) – Indicates from which side of the 2D grid the contraction algorithm
should start.</p></li>
<li><p><strong>max_bond</strong> (<em>int</em>) – The maximum allowed bond dimension. If, when contracting consecutive
lines (rows or columns) of the PEPS this bond dimension is exceeded,
the bond dimension is reduced using singular value decomposition
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code>).</p></li>
<li><p><strong>inline</strong> (<em>bool</em>) – Boolean indicating whether consecutive lines should be contracted
inline or in parallel (using a single stacked contraction).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="upeps">
<h3>UPEPS<a class="headerlink" href="#upeps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">UPEPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_rows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#UPEPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UPEPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform (translationally invariant) Projected Entangled Pair
States, where all nodes are input nodes. It is the uniform version of
<a class="reference internal" href="#tensorkrowch.models.PEPS" title="tensorkrowch.models.PEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PEPS</span></code></a>, that is, all nodes share the same tensor. Thus boundary
conditions are always periodic.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">UPEPS</span></code> is formed by the following nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">grid_env</span></code>: Grid environment of nodes with 5 edges, (“input”, “left”,
“right”, “up”, “down”). Is is a list of lists of nodes.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_rows</strong> (<em>int</em>) – Number of rows of the 2D grid.</p></li>
<li><p><strong>n_cols</strong> (<em>int</em>) – Number of columns of the 2D grid</p></li>
<li><p><strong>in_dim</strong> (<em>int</em>) – Input dimension. Equivalent to the physical dimension.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions for horizontal and vertical edges (in that order). Thus
it should also contain 2 elements</p></li>
<li><p><strong>n_batches</strong> (<em>int</em>) – Number of batch edges of input <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes. Usually <code class="docutils literal notranslate"><span class="pre">n_batches</span> <span class="pre">=</span> <span class="pre">1</span></code>
(where the batch edge is used for the data batched) but it could also
be <code class="docutils literal notranslate"><span class="pre">nu_batches</span> <span class="pre">=</span> <span class="pre">2</span></code> (one edge for data batched, other edge for image
patches in convolutional layers).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">PEPS</span><span class="p">(</span><span class="n">n_rows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">n_cols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">in_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">peps</span><span class="o">.</span><span class="n">grid_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># batch_size x n_features x feature_size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">peps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.n_rows">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_rows</span></span><a class="headerlink" href="#tensorkrowch.models.UPEPS.n_rows" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of rows of the 2D grid.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.n_cols">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_cols</span></span><a class="headerlink" href="#tensorkrowch.models.UPEPS.n_cols" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of columns of the 2D grid.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.in_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_dim</span></span><a class="headerlink" href="#tensorkrowch.models.UPEPS.in_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns input/physical dimension.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.bond_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_dim</span></span><a class="headerlink" href="#tensorkrowch.models.UPEPS.bond_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Returns bond dimensions for horizontal and vertical edges.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.n_batches">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_batches</span></span><a class="headerlink" href="#tensorkrowch.models.UPEPS.n_batches" title="Permalink to this definition">#</a></dt>
<dd><p>Returns number of batch edges of the <code class="docutils literal notranslate"><span class="pre">data</span></code> nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#UPEPS.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UPEPS.initialize" title="Permalink to this definition">#</a></dt>
<dd><p>Initializes all the nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.set_data_nodes">
<span class="sig-name descname"><span class="pre">set_data_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#UPEPS.set_data_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UPEPS.set_data_nodes" title="Permalink to this definition">#</a></dt>
<dd><p>Creates data nodes and connects each of them to the physical edge of
an input node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.UPEPS.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'up'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_bond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#UPEPS.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.UPEPS.contract" title="Permalink to this definition">#</a></dt>
<dd><p>Contracts the whole PEPS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_side</strong> (<em>{&quot;up&quot;</em><em>, </em><em>&quot;down&quot;</em><em>, </em><em>&quot;left&quot;</em><em>, </em><em>&quot;right&quot;}</em>) – Indicates from which side of the 2D grid the contraction algorithm
should start.</p></li>
<li><p><strong>max_bond</strong> (<em>int</em>) – The maximum allowed bond dimension. If, when contracting consecutive
lines (rows or columns) of the PEPS this bond dimension is exceeded,
the bond dimension is reduced using singular value decomposition
(see <code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code>).</p></li>
<li><p><strong>inline</strong> (<em>bool</em>) – Boolean indicating whether consecutive lines should be contracted
inline or in parallel (using a single stacked contraction).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="components.html#tensorkrowch.Node" title="tensorkrowch.Node">Node</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convpeps">
<h3>ConvPEPS<a class="headerlink" href="#convpeps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvPEPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['obc',</span> <span class="pre">'obc']</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#ConvPEPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvPEPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Projected Entangled Pair States, where all nodes are input nodes,
and where the input data is a batch of images. It is the convolutional
version of <a class="reference internal" href="#tensorkrowch.models.PEPS" title="tensorkrowch.models.PEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PEPS</span></code></a>.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.PEPS" title="tensorkrowch.models.PEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PEPS</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions for horizontal and vertical edges (in that order). Thus
it should also contain 2 elements</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>boundary</strong> (<em>list</em><em>[</em><em>{&quot;obc&quot;</em><em>, </em><em>&quot;pbc&quot;}</em><em>]</em>) – List of strings indicating whether periodic or open boundary conditions
should be used in the horizontal (up and down) and vertical (left and
right) boundaries.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_peps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvPEPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_peps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 1, 1])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.PEPS" title="tensorkrowch.models.PEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PEPS</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of rows and columns in the 2D grid is
given by <span class="math notranslate nohighlight">\(kernel\_size_0\)</span> and <span class="math notranslate nohighlight">\(kernel\_size_1\)</span>, respectively.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvPEPS.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#ConvPEPS.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvPEPS.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>’s forward to compute a convolution on the input
image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.PEPS.contract" title="tensorkrowch.models.PEPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.PEPS.contract" title="tensorkrowch.models.PEPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">from_size</span></code>, <code class="docutils literal notranslate"><span class="pre">max_bond</span></code> or inline.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="convupeps">
<h3>ConvUPEPS<a class="headerlink" href="#convupeps" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tensorkrowch.models.</span></span><span class="sig-name descname"><span class="pre">ConvUPEPS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#ConvUPEPS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS" title="Permalink to this definition">#</a></dt>
<dd><p>Class for Uniform Projected Entangled Pair States, where all nodes are input
nodes, and where the input data is a batch of images. It is the convolutional
version of <a class="reference internal" href="#tensorkrowch.models.UPEPS" title="tensorkrowch.models.UPEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UPEPS</span></code></a>.</p>
<p>Input data as well as initialization parameters are described in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>) – Input channels. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UPEPS" title="tensorkrowch.models.UPEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UPEPS</span></code></a>.</p></li>
<li><p><strong>bond_dim</strong> (<em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – Bond dimensions for horizontal and vertical edges (in that order). Thus
it should also contain 2 elements</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em><em>, </em><em>list</em><em>[</em><em>int</em><em>] or </em><em>tuple</em><em>[</em><em>int</em><em>]</em>) – <p>Kernel size used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – <p>Stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</p></li>
<li><p><strong>padding</strong> (<em>int</em>) – <p>Padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
<li><p><strong>dilation</strong> (<em>int</em>) – <p>Dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.
If given as an <code class="docutils literal notranslate"><span class="pre">int</span></code>, the actual kernel size will be
<code class="docutils literal notranslate"><span class="pre">(kernel_size,</span> <span class="pre">kernel_size)</span></code>.</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conv_peps</span> <span class="o">=</span> <span class="n">tk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ConvPEPS</span><span class="p">(</span><span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">bond_dim</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                               <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">conv_peps</span><span class="o">.</span><span class="n">grid_env</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">tensor_address</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;virtual_uniform&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># batch_size x in_channels x height x width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conv_peps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([20, 1, 1])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.in_channels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.in_channels" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">in_channels</span></code>. Same as <code class="docutils literal notranslate"><span class="pre">in_dim</span></code> in <a class="reference internal" href="#tensorkrowch.models.UPEPS" title="tensorkrowch.models.UPEPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">UPEPS</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.kernel_size" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code>. Number of rows and columns in the 2D grid is
given by <span class="math notranslate nohighlight">\(kernel\_size_0\)</span> and <span class="math notranslate nohighlight">\(kernel\_size_1\)</span>, respectively.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.stride">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.stride" title="Permalink to this definition">#</a></dt>
<dd><p>Returns stride used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.padding" title="Permalink to this definition">#</a></dt>
<dd><p>Returns padding used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.dilation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.dilation" title="Permalink to this definition">#</a></dt>
<dd><p>Returns dilation used in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold">torch.nn.Unfold</a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tensorkrowch.models.ConvUPEPS.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tensorkrowch/models/peps.html#ConvUPEPS.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tensorkrowch.models.ConvUPEPS.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Overrides <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>’s forward to compute a convolution on the input
image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch.Tensor</em>) – <p>Input batch of images with shape</p>
<div class="math notranslate nohighlight">
\[batch\_size \times in\_channels \times height \times width\]</div>
</p></li>
<li><p><strong>args</strong> – Arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.PEPS.contract" title="tensorkrowch.models.PEPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments that might be used in <a class="reference internal" href="#tensorkrowch.models.PEPS.contract" title="tensorkrowch.models.PEPS.contract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contract()</span></code></a>,
like <code class="docutils literal notranslate"><span class="pre">from_size</span></code>, <code class="docutils literal notranslate"><span class="pre">max_bond</span></code> or inline.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="operations.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Operations</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="initializers.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Initializers</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By José Ramón Pareja Monturiol<br/>
  
      &copy; Copyright 2023, José Ramón Pareja Monturiol.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>