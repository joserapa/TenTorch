{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Basics"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The main components of **TensorKrowch** are ``Nodes``, ``Edges`` and\n",
    "``TensorNetworks``. The latter are the kind of objects that are going\n",
    "to be trained. They are made up of a bunch of ``Nodes`` connected by\n",
    "``Edges``, forming a graph. Hence, all ``Nodes`` must be members of \n",
    "some ``TensorNetwork``."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([5, 5])\n"
     ]
    }
   ],
   "source": [
    "import tensorkrowch as tk\n",
    "\n",
    "# Create TensorNetwork\n",
    "net = tk.TensorNetwork(name='my_net')\n",
    "\n",
    "# Create Nodes in ``net``\n",
    "node1 = tk.randn(shape=(5, 3),\n",
    "                 axes_names=('input', 'right'),\n",
    "                 network=net)\n",
    "node2 = tk.randn(shape=(3, 5),\n",
    "                 axes_names=('left', 'input'),\n",
    "                 network=net)\n",
    "\n",
    "# Connect nodes\n",
    "node1['right'] ^ node2['left']\n",
    "\n",
    "# Contract nodes\n",
    "node3 = node1 @ node2\n",
    "print(node3.shape)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This way of manipulating ``TensorNetworks`` is just right for experimenting and\n",
    "playing around, but things can get real just with a few more lines of code. The\n",
    "workflow in **TensorKrowch** is similar to that of **PyTorch** when one wants to\n",
    "define a new ``nn.Module``. To do this, the layers are defined in the ``__init__``\n",
    "method, while the way in which these layers are combined to compute the output\n",
    "is described overriding the ``forward`` method.\n",
    "\n",
    "In **TensorKrowch**, the network itself should also be defined in the ``__init__``\n",
    "method of subclasses of ``TensorNetwork``. But instead of overriding ``forward``,\n",
    "here the method ``contract`` should be overriden to specify how the whole network\n",
    "should be contracted into a signle tensor. Also, optionally, the method\n",
    "``set_data_nodes`` can be overriden. This method creates the nodes that will\n",
    "store the input data tensors."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's rewrite the code above in a fancier way\n",
    "class MyNet(tk.TensorNetwork):\n",
    "    \n",
    "    def __init__(self):\n",
    "        super().__init__(name='my_net')\n",
    "        \n",
    "        # Now ``node1`` and ``node2`` are param-nodes, which means that\n",
    "        # these are trainable nodes. Otherwise, their tensors would be fixed.\n",
    "        node1 = tk.randn(shape=(5, 3),\n",
    "                         axes_names=('input', 'right'),\n",
    "                         network=self,\n",
    "                         param_node=True)\n",
    "        node2 = tk.randn(shape=(3, 5),\n",
    "                         axes_names=('left', 'input'),\n",
    "                         network=self,\n",
    "                         param_node=True)\n",
    "        \n",
    "        # Connect nodes\n",
    "        node1['right'] ^ node2['left']\n",
    "        \n",
    "        self.node1 = node1\n",
    "        self.node2 = node2\n",
    "        \n",
    "    def set_data_nodes(self):\n",
    "        input_edges = [self.node1['input'], self.node2['input']]\n",
    "        super().set_data_nodes(input_edges, 1)\n",
    "        \n",
    "    def contract(self):\n",
    "        # Find data nodes connected to each node\n",
    "        data1 = self.node1.neighbours('input')\n",
    "        data2 = self.node2.neighbours('input')\n",
    "        \n",
    "        # Contract the whole network\n",
    "        node1_aux = self.node1 @ data1\n",
    "        node2_aux = self.node2 @ data2\n",
    "        result = node1_aux @ node2_aux\n",
    "        \n",
    "        return result"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that we have defined the network as a subclass of ``TensorNetwork``, feeding\n",
    "it with input data is as easy as:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([100])\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "\n",
    "net = MyNet()\n",
    "\n",
    "data = torch.randn(2, 100, 5)  # n_features x batch_size x feature_size\n",
    "result = net(data)\n",
    "\n",
    "print(result.shape)  # batch_size"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ``node1`` and ``node2`` have gradients, they can be \"learned\"\n",
    "result.mean().backward()\n",
    "assert not torch.equal(net.node1.grad, torch.zeros(net.node1.shape))\n",
    "assert not torch.equal(net.node2.grad, torch.zeros(net.node2.shape))"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's move on to a more complex and recognizible model: Matrix Product States."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MPS(tk.TensorNetwork):\n",
    "    \n",
    "    def __init__(self):\n",
    "        super().__init__(name='MPS')\n",
    "        \n",
    "        # Create TN\n",
    "        input_nodes = []\n",
    "        for _ in range(10 * 10):\n",
    "            node = tk.ParamNode(shape=(10, 2, 10),\n",
    "                                axes_names=('left', 'input', 'right'),\n",
    "                                name='input_node',\n",
    "                                network=self)\n",
    "            input_nodes.append(node)\n",
    "            \n",
    "        for i in range(len(input_nodes) - 1):\n",
    "            input_nodes[i]['right'] ^ input_nodes[i + 1]['left']\n",
    "            \n",
    "        output_node = tk.ParamNode(shape=(10, 10, 10),\n",
    "                                    axes_names=('left', 'output', 'right'),\n",
    "                                    name='output_node',\n",
    "                                    network=self)\n",
    "        output_node['right'] ^ input_nodes[0]['left']\n",
    "        output_node['left'] ^ input_nodes[-1]['right']\n",
    "        \n",
    "        self.input_nodes = input_nodes\n",
    "        self.output_node = output_node\n",
    "        \n",
    "        # Initialize nodes\n",
    "        std = 1e-9\n",
    "        for node in input_nodes:\n",
    "            tensor = torch.randn(node.shape) * std\n",
    "            random_eye = torch.randn(tensor.shape[0],\n",
    "                                     tensor.shape[2]) * std\n",
    "            random_eye  = random_eye + torch.eye(tensor.shape[0],\n",
    "                                                 tensor.shape[2])\n",
    "            tensor[:, 0, :] = random_eye\n",
    "            \n",
    "            node.tensor = tensor\n",
    "                \n",
    "        eye_tensor = torch.eye(\n",
    "            output_node.shape[0],\n",
    "            output_node.shape[2]).view(\n",
    "                [output_node.shape[0], 1,\n",
    "                 output_node.shape[2]])\n",
    "        eye_tensor = eye_tensor.expand(output_node.shape)\n",
    "        tensor = eye_tensor + std * torch.randn(output_node.shape)\n",
    "        \n",
    "        output_node.tensor = tensor\n",
    "        \n",
    "        self.input_nodes = input_nodes\n",
    "        self.output_node = output_node\n",
    "        \n",
    "    def set_data_nodes(self) -> None:\n",
    "        input_edges = []\n",
    "        for node in self.input_nodes:\n",
    "            input_edges.append(node['input'])\n",
    "                \n",
    "        super().set_data_nodes(input_edges, 1)\n",
    "    \n",
    "    def contract(self):\n",
    "        # Parallel contraction of input\n",
    "        stack_input = tk.stack(self.input_nodes)\n",
    "        stack_data = tk.stack(list(self.data_nodes.values()))\n",
    "        \n",
    "        # Re-connect stacks\n",
    "        stack_input['input'] ^ stack_data['feature']\n",
    "        stack_result = stack_input @ stack_data\n",
    "        \n",
    "        # Unbind result\n",
    "        stack_result = tk.unbind(stack_result)\n",
    "        \n",
    "        # Inline contraction of final matrices\n",
    "        result = stack_result[0]\n",
    "        for node in stack_result[1:]:\n",
    "            result @= node\n",
    "        result @= self.output_node\n",
    "        \n",
    "        return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time: 0.0105\n",
      "Time: 0.0100\n",
      "Time: 0.0094\n",
      "Time: 0.0095\n",
      "Time: 0.0093\n"
     ]
    }
   ],
   "source": [
    "import time\n",
    "\n",
    "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n",
    "\n",
    "mps = MPS()\n",
    "mps = mps.to(device)  # Model can be sent to GPU\n",
    "\n",
    "# Input image\n",
    "image = torch.randn(500, 10, 10)  # batch_size x height x width\n",
    "image = tk.add_ones(image, dim=1) # Embedds tensor adding a 1 as the\n",
    "                                  # first component of each vector\n",
    "image = image.to(device)\n",
    "image = image.view(500, 2, 10 * 10).permute(2, 0, 1)\n",
    "\n",
    "# Modes to manage memory efficiently while training\n",
    "mps.automemory = True\n",
    "mps.auto_unbind = True\n",
    "\n",
    "# Tracing computes all network operations with an input example\n",
    "# in order to set everything up before training, which helps to\n",
    "# save time in subsequent contractions\n",
    "mps.trace(torch.zeros(10 * 10, 1, 2).to(device))\n",
    "\n",
    "# Forward\n",
    "for _ in range(5):\n",
    "    start = time.time()\n",
    "    result = mps(image)\n",
    "    print(f'Time: {time.time() - start:.4f}')"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Of course, there is also a pre-defined way of instantiating ``MPS``:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "__init__() got an unexpected keyword argument 'inline_input'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[7], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[39m# MPSLayer has output node, MPS doesn't\u001b[39;00m\n\u001b[0;32m----> 2\u001b[0m mps \u001b[39m=\u001b[39m tk\u001b[39m.\u001b[39;49mMPSLayer(n_sites\u001b[39m=\u001b[39;49m\u001b[39m10\u001b[39;49m \u001b[39m*\u001b[39;49m \u001b[39m10\u001b[39;49m \u001b[39m+\u001b[39;49m \u001b[39m1\u001b[39;49m, \u001b[39m# Number of sites\u001b[39;49;00m\n\u001b[1;32m      3\u001b[0m                   d_phys\u001b[39m=\u001b[39;49m\u001b[39m2\u001b[39;49m,            \u001b[39m# Physical dimension\u001b[39;49;00m\n\u001b[1;32m      4\u001b[0m                   n_labels\u001b[39m=\u001b[39;49m\u001b[39m10\u001b[39;49m,         \u001b[39m# Output physical dimension (num. labels)\u001b[39;49;00m\n\u001b[1;32m      5\u001b[0m                   d_bond\u001b[39m=\u001b[39;49m\u001b[39m10\u001b[39;49m,           \u001b[39m# Bond dimension\u001b[39;49;00m\n\u001b[1;32m      6\u001b[0m                   boundary\u001b[39m=\u001b[39;49m\u001b[39m'\u001b[39;49m\u001b[39mpbc\u001b[39;49m\u001b[39m'\u001b[39;49m,      \u001b[39m# Periodic boundary conditions\u001b[39;49;00m\n\u001b[1;32m      7\u001b[0m                   param_bond\u001b[39m=\u001b[39;49m\u001b[39mFalse\u001b[39;49;00m,    \u001b[39m# Trainable edges\u001b[39;49;00m\n\u001b[1;32m      8\u001b[0m                   num_batches\u001b[39m=\u001b[39;49m\u001b[39m1\u001b[39;49m,       \u001b[39m# Number of batch edges in data nodes\u001b[39;49;00m\n\u001b[1;32m      9\u001b[0m                   inline_input\u001b[39m=\u001b[39;49m\u001b[39mFalse\u001b[39;49;00m,  \u001b[39m# Contract input data nodes inline or in parallel\u001b[39;49;00m\n\u001b[1;32m     10\u001b[0m                   inline_mats\u001b[39m=\u001b[39;49m\u001b[39mFalse\u001b[39;49;00m)   \u001b[39m# Contract final matrices inline or pairwise\u001b[39;00m\n\u001b[1;32m     12\u001b[0m mps \u001b[39m=\u001b[39m mps\u001b[39m.\u001b[39mto(device)\n\u001b[1;32m     13\u001b[0m mps\u001b[39m.\u001b[39mautomemory \u001b[39m=\u001b[39m \u001b[39mTrue\u001b[39;00m\n",
      "\u001b[0;31mTypeError\u001b[0m: __init__() got an unexpected keyword argument 'inline_input'"
     ]
    }
   ],
   "source": [
    "# MPSLayer has output node, MPS doesn't\n",
    "mps = tk.MPSLayer(n_sites=10 * 10 + 1, # Number of sites\n",
    "                  d_phys=2,            # Physical dimension\n",
    "                  n_labels=10,         # Output physical dimension (num. labels)\n",
    "                  d_bond=10,           # Bond dimension\n",
    "                  boundary='pbc',      # Periodic boundary conditions\n",
    "                  param_bond=False,    # Trainable edges\n",
    "                  num_batches=1,       # Number of batch edges in data nodes\n",
    "                  inline_input=False,  # Contract input data nodes inline or in parallel\n",
    "                  inline_mats=False)   # Contract final matrices inline or pairwise\n",
    "\n",
    "mps = mps.to(device)\n",
    "mps.automemory = True\n",
    "mps.auto_unbind = True\n",
    "\n",
    "mps.trace(torch.zeros(10 * 10, 1, 2).to(device))\n",
    "\n",
    "# Forward\n",
    "for _ in range(5):\n",
    "    start = time.time()\n",
    "    result = mps(image)\n",
    "    print(f'Time: {time.time() - start:.4f}')"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Besides, since the class ``TensorNetwork`` is a subclass of ``nn.Module``, one\n",
    "can make a network a sub-module of a larger model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch.nn as nn\n",
    "\n",
    "class MyModel(nn.Module):\n",
    "    \n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        \n",
    "        self.mps = tk.MPSLayer(n_sites=10,\n",
    "                               d_phys=5,\n",
    "                               n_labels=20,\n",
    "                               d_bond=10)\n",
    "        self.linear = nn.Linear(20, 1)\n",
    "        \n",
    "    def forward(self, x):\n",
    "        x = self.mps(x)\n",
    "        x = self.linear(x)\n",
    "        return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([100, 1])\n"
     ]
    }
   ],
   "source": [
    "data = torch.randn(9, 100, 5).to(device)  # n_features x batch_size x feature_size\n",
    "\n",
    "model = MyModel()\n",
    "model.to(device)\n",
    "\n",
    "result = model(data)\n",
    "print(result.shape)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "pytorch",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.15"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "98819ef66e0fd8e26166ef23b2736d781c80dc7aa950207c762e497c21afbd1c"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
